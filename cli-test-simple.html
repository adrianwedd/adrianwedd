<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLI Command Audit - Simple Test</title>
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #0d1117;
            color: #00ff41;
            padding: 20px;
            line-height: 1.4;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid #00ff41;
            padding: 20px;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #333;
            background: rgba(0, 255, 65, 0.05);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #00ff41;
            background: rgba(0, 255, 65, 0.1);
        }
        .results {
            margin-top: 20px;
        }
        .command-result {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 2px 0;
            border-radius: 3px;
        }
        .passed { background: rgba(0, 255, 0, 0.2); }
        .failed { background: rgba(255, 0, 0, 0.2); }
        .error { background: rgba(255, 165, 0, 0.2); }
        .no-output { background: rgba(255, 255, 0, 0.2); color: #ffff00; }
        
        .summary {
            padding: 15px;
            margin: 20px 0;
            border: 2px solid #00ff41;
            background: rgba(0, 255, 65, 0.1);
        }
        
        button {
            background: transparent;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .terminal-frame {
            width: 100%;
            height: 600px;
            border: 2px solid #00ff41;
            margin: 10px 0;
            display: none;
            border-radius: 5px;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff41, #41ff00);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 CLI Command Audit Tool</h1>
            <p>Comprehensive testing of Adrian Wedd terminal commands</p>
        </div>
        
        <div class="controls">
            <h3>🎛️ Test Controls</h3>
            <button onclick="startFullAudit()">🚀 Run Full Audit</button>
            <button onclick="startQuickTest()">⚡ Quick Test (Basic Commands)</button>
            <button onclick="stopTest()" id="stopBtn" disabled>🛑 Stop Test</button>
            <button onclick="clearResults()">🧹 Clear Results</button>
            <button onclick="downloadReport()">💾 Download Report</button>
            <button onclick="createGitHubIssuesManual()">🐙 Create GitHub Issues</button>
            <br><br>
            <label>
                Target URL: 
                <input type="url" id="targetUrl" value="../index.html" style="background: #333; border: 1px solid #555; color: #00ff41; padding: 5px;">
            </label>
            <br><br>
            <label>
                <input type="checkbox" id="showTerminal"> Show Terminal Frame
            </label>
        </div>
        
        <div class="status" id="status">
            Ready to test. Click a button to start.
        </div>
        
        <div class="progress" id="progressContainer" style="display: none;">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <iframe id="terminalFrame" class="terminal-frame" src="about:blank"></iframe>
        
        <div class="summary" id="summary" style="display: none;">
            <h3>📊 Test Summary</h3>
            <div id="summaryContent"></div>
        </div>
        
        <div class="results" id="results"></div>
    </div>

    <script>
        // CLI Test Configuration
        const commands = {
            basic: ['help', 'about', 'whoami', 'pwd', 'clear'],
            content: ['projects', 'skills', 'home', 'ls'],
            system: ['uptime', 'neofetch', 'ps'],
            interactive: ['history', 'theme list'],
            effects: ['matrix', 'theme matrix'],
            ai: ['cache stats', 'tokens'],
            dev: ['script list', 'debug on']
        };
        
        let isRunning = false;
        let currentTest = null;
        let results = {
            total: 0,
            passed: 0,
            failed: 0,
            errors: 0,
            noOutput: 0,
            details: {}
        };
        
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            const emoji = {
                info: '📡',
                success: '✅',
                error: '❌',
                warning: '⚠️'
            };
            status.innerHTML = `${emoji[type] || '📡'} ${message}`;
        }
        
        function updateProgress(current, total) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            
            if (total > 0) {
                container.style.display = 'block';
                const percentage = (current / total) * 100;
                bar.style.width = `${percentage}%`;
            } else {
                container.style.display = 'none';
            }
        }
        
        function addResult(command, status, time, output = '') {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `command-result ${status}`;
            
            const statusEmoji = {
                passed: '✅',
                failed: '❌',
                error: '💥',
                'no-output': '⚠️'
            };
            
            resultDiv.innerHTML = `
                <span>${statusEmoji[status]} ${command}</span>
                <span>${time}ms</span>
            `;
            
            if (output && (status === 'failed' || status === 'error')) {
                resultDiv.title = output;
            }
            
            resultsDiv.appendChild(resultDiv);
            results.details[command] = { status, time, output };
        }
        
        function updateSummary() {
            const summary = document.getElementById('summary');
            const content = document.getElementById('summaryContent');
            
            const passRate = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(1) : 0;
            
            content.innerHTML = `
                <div>📈 Total Commands: ${results.total}</div>
                <div>✅ Passed: ${results.passed} (${passRate}%)</div>
                <div>❌ Failed: ${results.failed}</div>
                <div>💥 Errors: ${results.errors}</div>
                <div>⚠️ No Output: ${results.noOutput}</div>
            `;
            
            summary.style.display = 'block';
        }
        
        async function testCommand(iframe, command, timeout = 5000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                
                try {
                    const iframeWindow = iframe.contentWindow;
                    
                    // Check if terminal is available
                    if (!iframeWindow.terminal) {
                        resolve({
                            status: 'error',
                            time: Date.now() - startTime,
                            output: 'Terminal not available',
                            fullOutput: ''
                        });
                        return;
                    }
                    
                    // Wait for any previous commands to complete
                    setTimeout(() => {
                        // Get current output state
                        const outputElement = iframeWindow.document.getElementById('terminalOutput');
                        const initialContent = outputElement ? outputElement.innerHTML : '';
                        const initialLength = outputElement ? outputElement.children.length : 0;
                        
                        // Execute command
                        const input = iframeWindow.document.getElementById('commandInput');
                        if (!input) {
                            resolve({
                                status: 'error',
                                time: Date.now() - startTime,
                                output: 'Command input not found',
                                fullOutput: ''
                            });
                            return;
                        }
                        
                        // Clear and focus input first
                        input.value = '';
                        input.focus();
                        
                        // Type command and press enter
                        input.value = command;
                        const enterEvent = new KeyboardEvent('keydown', { 
                            key: 'Enter', 
                            code: 'Enter',
                            keyCode: 13,
                            which: 13,
                            bubbles: true 
                        });
                        input.dispatchEvent(enterEvent);
                        
                        // Wait longer for output with multiple checks
                        let checkCount = 0;
                        const maxChecks = 10;
                        
                        const checkOutput = () => {
                            checkCount++;
                            const finalLength = outputElement ? outputElement.children.length : 0;
                            const finalContent = outputElement ? outputElement.innerHTML : '';
                            const hasNewOutput = finalLength > initialLength || finalContent !== initialContent;
                            
                            // If no new output and we haven't reached max checks, wait more
                            if (!hasNewOutput && checkCount < maxChecks) {
                                setTimeout(checkOutput, 500);
                                return;
                            }
                            
                            let status = 'no-output';
                            let output = '';
                            let fullOutput = outputElement ? outputElement.textContent.trim() : '';
                            
                            if (hasNewOutput) {
                                const content = finalContent.toLowerCase();
                                const textContent = outputElement.textContent.toLowerCase();
                                
                                // More comprehensive error detection
                                if (content.includes('error') || content.includes('❌') || 
                                    content.includes('unknown') || content.includes('failed') ||
                                    textContent.includes('command not found') || 
                                    textContent.includes('not recognized')) {
                                    status = 'failed';
                                    output = 'Command produced error output';
                                } else if (content.includes('✅') || content.includes('success') ||
                                          fullOutput.length > 10) { // Any substantial output
                                    status = 'passed';
                                    output = 'Command executed successfully';
                                } else {
                                    status = 'passed'; // Assume success if output but no error indicators
                                    output = 'Command executed with output';
                                }
                            }
                            
                            resolve({
                                status,
                                time: Date.now() - startTime,
                                output,
                                fullOutput: fullOutput.substring(0, 500) // Limit output length
                            });
                        };
                        
                        // Start checking after initial delay
                        setTimeout(checkOutput, 1000);
                        
                    }, 200); // Initial delay for previous command cleanup
                    
                } catch (error) {
                    resolve({
                        status: 'error',
                        time: Date.now() - startTime,
                        output: error.message,
                        fullOutput: ''
                    });
                }
            });
        }
        
        async function runTestSuite(commandSet) {
            const iframe = document.getElementById('terminalFrame');
            const targetUrl = document.getElementById('targetUrl').value;
            const showTerminal = document.getElementById('showTerminal').checked;
            
            // Show terminal frame if requested
            iframe.style.display = showTerminal ? 'block' : 'none';
            
            updateStatus('Loading terminal...', 'info');
            
            return new Promise((resolve, reject) => {
                iframe.src = targetUrl;
                
                iframe.onload = async () => {
                    try {
                        // Wait for terminal to initialize and boot sequence to complete
                        updateStatus('Waiting for terminal boot sequence...', 'info');
                        
                        // Wait for window.terminal to be available
                        await new Promise((resolve) => {
                            const checkTerminal = () => {
                                if (iframe.contentWindow.terminal) {
                                    resolve();
                                } else {
                                    setTimeout(checkTerminal, 100);
                                }
                            };
                            checkTerminal();
                        });
                        
                        // Wait for boot sequence to complete
                        await new Promise((resolve) => {
                            const checkBootComplete = () => {
                                const terminal = iframe.contentWindow.terminal;
                                if (terminal && !terminal.isBooting) {
                                    resolve();
                                } else {
                                    setTimeout(checkBootComplete, 500);
                                }
                            };
                            checkBootComplete();
                        });
                        
                        // Additional safety delay
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        updateStatus('Terminal loaded, starting tests...', 'success');
                        
                        // Collect all commands
                        const allCommands = [];
                        if (Array.isArray(commandSet)) {
                            allCommands.push(...commandSet);
                        } else {
                            for (const category of Object.keys(commandSet)) {
                                allCommands.push(...commandSet[category]);
                            }
                        }
                        
                        let completed = 0;
                        
                        // Test each command
                        for (const command of allCommands) {
                            if (!isRunning) break;
                            
                            updateStatus(`Testing: ${command}`, 'info');
                            updateProgress(completed, allCommands.length);
                            
                            const result = await testCommand(iframe, command);
                            
                            // Update counters
                            results.total++;
                            if (result.status === 'passed') results.passed++;
                            else if (result.status === 'failed') results.failed++;
                            else if (result.status === 'error') results.errors++;
                            else if (result.status === 'no-output') results.noOutput++;
                            
                            addResult(command, result.status, result.time, result.output);
                            
                            // Store detailed result
                            results.details[command] = {
                                ...result,
                                timestamp: new Date().toISOString(),
                                category: getCategoryForCommand(command)
                            };
                            
                            updateSummary();
                            
                            completed++;
                            // Longer delay between commands to prevent overlap
                            await new Promise(resolve => setTimeout(resolve, 1500));
                        }
                        
                        updateProgress(completed, allCommands.length);
                        updateStatus(`Test complete! Tested ${completed} commands.`, 'success');
                        
                        // Auto-save results
                        const reportData = saveResults();
                        updateStatus(`Test complete! Report saved automatically.`, 'success');
                        
                        // Check for failures and show GitHub issue creation option
                        if (results.failed > 0 || results.errors > 0) {
                            setTimeout(() => {
                                if (confirm(`Found ${results.failed + results.errors} failed commands. Create GitHub issues?`)) {
                                    createGitHubIssues(reportData);
                                }
                            }, 1000);
                        }
                        
                        resolve();
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                
                iframe.onerror = () => {
                    reject(new Error('Failed to load terminal'));
                };
            });
        }
        
        async function startFullAudit() {
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('stopBtn').disabled = false;
            clearResults();
            
            try {
                await runTestSuite(commands);
            } catch (error) {
                updateStatus(`Test failed: ${error.message}`, 'error');
            } finally {
                isRunning = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        async function startQuickTest() {
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('stopBtn').disabled = false;
            clearResults();
            
            try {
                await runTestSuite(commands.basic);
            } catch (error) {
                updateStatus(`Test failed: ${error.message}`, 'error');
            } finally {
                isRunning = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function stopTest() {
            isRunning = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('Test stopped by user', 'warning');
        }
        
        function getCategoryForCommand(command) {
            for (const [category, cmds] of Object.entries(commands)) {
                if (cmds.includes(command) || cmds.some(cmd => command.startsWith(cmd))) {
                    return category;
                }
            }
            return 'unknown';
        }
        
        function saveResults() {
            const reportData = {
                ...results,
                testRun: {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: document.getElementById('targetUrl').value,
                    version: '1.0'
                }
            };
            
            // Save to localStorage
            const reportKey = `cli-audit-${Date.now()}`;
            localStorage.setItem(reportKey, JSON.stringify(reportData));
            localStorage.setItem('cli-audit-latest', JSON.stringify(reportData));
            
            // Create downloadable report
            const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cli-audit-report-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            return reportData;
        }
        
        function loadPreviousResults() {
            const previous = localStorage.getItem('cli-audit-latest');
            if (previous) {
                const data = JSON.parse(previous);
                updateStatus(`Previous report found: ${data.testRun.timestamp}`, 'info');
                return data;
            }
            return null;
        }
        
        async function createGitHubIssues(reportData) {
            const failedCommands = Object.entries(reportData.details)
                .filter(([cmd, result]) => result.status === 'failed' || result.status === 'error');
            
            if (failedCommands.length === 0) {
                alert('No failed commands to create issues for.');
                return;
            }
            
            // Create markdown content for each failed command
            for (const [command, result] of failedCommands) {
                const issueTitle = `🐛 CLI Command '${command}' failing in terminal interface`;
                const issueBody = `## 🐛 Command Failure Report

**Command:** \`${command}\`
**Status:** ${result.status}
**Category:** ${result.category}
**Execution Time:** ${result.time}ms
**Timestamp:** ${result.timestamp}

### 📋 Error Details
**Output:** ${result.output}

### 🖥️ Full Terminal Output
\`\`\`
${result.fullOutput || 'No output captured'}
\`\`\`

### 🔍 Test Environment
- **URL:** ${reportData.testRun.url}
- **User Agent:** ${reportData.testRun.userAgent}
- **Test Version:** ${reportData.testRun.version}

### 📊 Test Summary
- **Total Commands:** ${reportData.total}
- **Pass Rate:** ${((reportData.passed / reportData.total) * 100).toFixed(1)}%

### ✅ Acceptance Criteria
- [ ] Command executes without errors
- [ ] Command produces expected output
- [ ] Command completes within reasonable time
- [ ] Output matches expected format/content

### 🔧 Additional Context
This issue was automatically generated by the CLI audit system. The command may:
- Have syntax errors in its implementation
- Be missing required dependencies or setup
- Have timing issues with async operations
- Need updated error handling

---
🤖 Generated by CLI Audit Tool - ${new Date().toISOString()}`;

                // Create GitHub issue URL (opens in new tab)
                const repoUrl = 'https://github.com/adrianwedd/adrianwedd';
                const issueUrl = `${repoUrl}/issues/new?title=${encodeURIComponent(issueTitle)}&body=${encodeURIComponent(issueBody)}&labels=bug,cli,automated-test`;
                
                // Open in new tab
                window.open(issueUrl, '_blank');
                
                // Delay between opening tabs
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            updateStatus(`Opened ${failedCommands.length} GitHub issue tabs`, 'success');
        }
        
        function createGitHubIssuesManual() {
            if (results.total === 0) {
                alert('No test results available. Run a test first.');
                return;
            }
            
            const reportData = {
                ...results,
                testRun: {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: document.getElementById('targetUrl').value,
                    version: '1.0'
                }
            };
            
            createGitHubIssues(reportData);
        }
        
        function downloadReport() {
            if (results.total === 0) {
                alert('No test results available. Run a test first.');
                return;
            }
            
            saveResults();
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            results = { total: 0, passed: 0, failed: 0, errors: 0, noOutput: 0, details: {} };
            updateProgress(0, 0);
        }
        
        // Show/hide terminal frame
        document.getElementById('showTerminal').onchange = function() {
            const iframe = document.getElementById('terminalFrame');
            iframe.style.display = this.checked ? 'block' : 'none';
        };
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadPreviousResults();
            updateStatus('Ready to test. Previous results loaded if available.', 'info');
        });
    </script>
</body>
</html>