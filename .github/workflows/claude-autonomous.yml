name: ü§ñ Autonomous Task Completion

on:
  schedule:
    # Run every 4 hours starting at midnight AEST (14:00 UTC)
    - cron: '0 14,18,22,2,6,10 * * *'
  workflow_dispatch:
    inputs:
      max_issues:
        description: 'Maximum number of issues to process'
        required: false
        default: '3'
        type: string
      generate_report:
        description: 'Generate detailed token usage report'
        required: false
        default: false
        type: boolean
      priority_filter:
        description: 'Priority filter (high, medium, low, all)'
        required: false
        default: 'high'
        type: choice
        options:
          - high
          - medium 
          - low
          - all

jobs:
  autonomous-tasks:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read

    steps:
      - name: üìä Check Usage History (Max/Pro Compatible)
        id: token-check
        run: |
          # Create usage tracking file with Max/Pro account compatibility
          mkdir -p .github/data
          USAGE_FILE=".github/data/usage-tracking.json"
          
          # Detect authentication method for proper limit calculation
          if [ -n "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
            AUTH_METHOD="claude-max-oauth"
            echo "üîê Detected Claude Max/Pro OAuth authentication"
          elif [ -n "$ANTHROPIC_API_KEY" ]; then
            AUTH_METHOD="anthropic-api"
            echo "üîê Detected Anthropic API key authentication"
          else
            AUTH_METHOD="none"
            echo "üîß No authentication - using rule-based processing"
          fi
          
          if [ ! -f "$USAGE_FILE" ]; then
            echo '{
              "auth_method": "'$AUTH_METHOD'",
              "session_usage": [],
              "five_hour_sessions": [],
              "last_session_reset": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "metadata": {
                "max_pro_limits": {
                  "pro_prompts_per_5h": 40,
                  "max_5x_prompts_per_5h": 200,
                  "max_20x_prompts_per_5h": 800,
                  "session_length_hours": 5
                },
                "api_limits": {
                  "daily_tokens": 100000
                },
                "created": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                "version": "2.0"
              }
            }' > "$USAGE_FILE"
          fi
          
          # Calculate 5-hour session boundaries for Max/Pro accounts
          CURRENT_TIME=$(date -u +%s)
          LAST_SESSION_TIME=$(date -d "$(jq -r '.last_session_reset' "$USAGE_FILE")" +%s 2>/dev/null || echo "0")
          FIVE_HOURS_AGO=$((CURRENT_TIME - 18000)) # 5 hours = 18000 seconds
          
          # Check if we need to reset 5-hour session for Max/Pro
          if [ "$AUTH_METHOD" = "claude-max-oauth" ] && [ "$LAST_SESSION_TIME" -lt "$FIVE_HOURS_AGO" ]; then
            echo "üîÑ Resetting 5-hour session limits for Claude Max/Pro account"
            jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '.
              | .five_hour_sessions = []
              | .last_session_reset = $timestamp' "$USAGE_FILE" > "$USAGE_FILE.tmp"
            mv "$USAGE_FILE.tmp" "$USAGE_FILE"
          fi
          
          # Calculate usage limits based on authentication method
          if [ "$AUTH_METHOD" = "claude-max-oauth" ]; then
            # Max/Pro account - message-based limits per 5-hour session
            SESSION_PROMPTS_TODAY=$(jq '.five_hour_sessions | length' "$USAGE_FILE")
            
            # Conservative estimates for autonomous workflow (assume Max 5x plan)
            MAX_PROMPTS_PER_SESSION=200
            PROMPTS_REMAINING=$((MAX_PROMPTS_PER_SESSION - SESSION_PROMPTS_TODAY))
            
            echo "üìä Claude Max/Pro Usage Analysis:"
            echo "- Account Type: Max/Pro (5-hour sessions)"
            echo "- Session Prompts Used: $SESSION_PROMPTS_TODAY"
            echo "- Estimated Session Limit: $MAX_PROMPTS_PER_SESSION prompts"
            echo "- Prompts Remaining: $PROMPTS_REMAINING"
            echo "- Session resets every 5 hours"
            
            # Determine if we should proceed (conservative approach)
            if [ "$PROMPTS_REMAINING" -lt 10 ]; then
              echo "‚ö†Ô∏è Approaching 5-hour session limit, waiting for reset"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "limit_reason=session_limit" >> $GITHUB_OUTPUT
            elif [ "$PROMPTS_REMAINING" -lt 50 ]; then
              echo "üí° Limited prompts remaining, reducing scope"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=1" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Sufficient prompts available in current session"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=3" >> $GITHUB_OUTPUT
            fi
            
            echo "estimated_usage=prompt_based" >> $GITHUB_OUTPUT
            echo "prompts_remaining=$PROMPTS_REMAINING" >> $GITHUB_OUTPUT
            echo "tokens_remaining=$PROMPTS_REMAINING" >> $GITHUB_OUTPUT  # For compatibility
            
          elif [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API key - token-based daily limits (detect tier based on usage patterns)
            TOKENS_USED_TODAY=$(jq '.session_usage | map(.total_tokens // 0) | add // 0' "$USAGE_FILE")
            
            # Detect API tier based on typical usage patterns and set appropriate limits
            # Free tier: ~25k tokens/day, Paid tier: ~100k+ tokens/day
            if [ "$TOKENS_USED_TODAY" -gt 50000 ] || [ -n "${{ github.event.inputs.force_paid_tier }}" ]; then
              DAILY_TOKENS=200000  # Paid tier - more generous limit
              API_TIER="paid"
              MIN_TOKENS=10000     # Higher threshold for paid accounts
            else
              DAILY_TOKENS=25000   # Free tier - conservative limit
              API_TIER="free"
              MIN_TOKENS=2000      # Lower threshold for free accounts
            fi
            
            TOKENS_REMAINING=$((DAILY_TOKENS - TOKENS_USED_TODAY))
            
            echo "üìä Anthropic API Usage Analysis:"
            echo "- Account Type: API Key ($API_TIER tier)"
            echo "- Daily Limit: $DAILY_TOKENS tokens"
            echo "- Used Today: $TOKENS_USED_TODAY tokens"
            echo "- Remaining: $TOKENS_REMAINING tokens"
            echo "- Minimum Required: $MIN_TOKENS tokens"
            
            if [ "$TOKENS_REMAINING" -lt "$MIN_TOKENS" ]; then
              echo "‚ö†Ô∏è Insufficient token budget remaining for $API_TIER tier"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "limit_reason=token_limit" >> $GITHUB_OUTPUT
            elif [ "$API_TIER" = "free" ] && [ "$TOKENS_REMAINING" -lt 10000 ]; then
              echo "üí° Limited tokens remaining on free tier, reducing scope"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=1" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Sufficient tokens available for $API_TIER tier"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=$( [ "$API_TIER" = "free" ] && echo "2" || echo "3" )" >> $GITHUB_OUTPUT
            fi
            
            # Set estimated usage based on tier and remaining tokens
            ESTIMATED_USAGE=$( [ "$API_TIER" = "free" ] && echo "3000" || echo "8000" )
            echo "estimated_usage=$ESTIMATED_USAGE" >> $GITHUB_OUTPUT
            echo "tokens_remaining=$TOKENS_REMAINING" >> $GITHUB_OUTPUT
            echo "api_tier=$API_TIER" >> $GITHUB_OUTPUT
            
          else
            # No authentication - always proceed with rule-based processing
            echo "üìä Rule-based Processing (No API limits):"
            echo "- Mode: Issue analysis and suggestions only"
            echo "- No external API calls required"
            echo "‚úÖ Always available for rule-based automation"
            
            echo "proceed=true" >> $GITHUB_OUTPUT
            echo "max_issues=5" >> $GITHUB_OUTPUT
            echo "estimated_usage=none" >> $GITHUB_OUTPUT
            echo "limit_reason=none" >> $GITHUB_OUTPUT
            echo "tokens_remaining=unlimited" >> $GITHUB_OUTPUT  # For compatibility
          fi
          
          echo "auth_method=$AUTH_METHOD" >> $GITHUB_OUTPUT
          echo "session_number=1" >> $GITHUB_OUTPUT
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üöÄ Checkout Repository  
        if: steps.token-check.outputs.proceed == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Fetch Open Issues
        id: fetch-issues
        if: steps.token-check.outputs.proceed == 'true'
        run: |
          # Fetch open issues with specific labels and priorities
          PRIORITY_FILTER="${{ github.event.inputs.priority_filter || 'high' }}"
          MAX_ISSUES="${{ github.event.inputs.max_issues || steps.token-check.outputs.max_issues || '3' }}"
          
          # Build label filter with fallback priority strategy
          echo "üîç Searching for issues with priority: $PRIORITY_FILTER"
          
          if [ "$PRIORITY_FILTER" = "all" ]; then
            echo "üìã Using no priority filter - checking all open issues"
          else
            echo "üéØ Filtering for \"priority: ${PRIORITY_FILTER}\" issues"
          fi
          
          # Fetch issues (excluding draft, wip, blocked)
          echo "üì• Fetching open issues..."
          if [ "$PRIORITY_FILTER" = "all" ]; then
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --json number,title,labels,body,url > all_issues.json
          else
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: ${PRIORITY_FILTER}" \
              --json number,title,labels,body,url > all_issues.json
          fi
          
          # Filter out draft, wip, blocked issues
          jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues.json > issues.json
          
          # Debug: Show what we fetched
          echo "üîç Debug: Issues fetched from GitHub:"
          cat all_issues.json | jq length
          echo "üîç Debug: Issues after filtering:"
          cat issues.json | jq length
          
          # Get count with error handling
          ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
          echo "üìä Found $ISSUE_COUNT issues with priority:${PRIORITY_FILTER}"
          
          # Ensure ISSUE_COUNT is a valid integer
          if [ -z "$ISSUE_COUNT" ] || ! [[ "$ISSUE_COUNT" =~ ^[0-9]+$ ]]; then
            ISSUE_COUNT="0"
          fi
          
          # If no high priority issues found, try medium priority
          if [ "$ISSUE_COUNT" -eq 0 ] && [ "$PRIORITY_FILTER" = "high" ]; then
            echo "‚¨áÔ∏è No high priority issues found, falling back to medium priority..."
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: medium" \
              --json number,title,labels,body,url > all_issues_medium.json
            
            # Filter out draft, wip, blocked issues
            jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues_medium.json > issues.json
            
            ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
            echo "üìä Found $ISSUE_COUNT medium priority issues"
            PRIORITY_FILTER="medium (fallback)"
          fi
          
          echo "‚úÖ Final issue count: $ISSUE_COUNT eligible issues for processing"
          echo "issue_count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
          echo "actual_priority=$PRIORITY_FILTER" >> $GITHUB_OUTPUT
          
          if [ "$ISSUE_COUNT" -gt 0 ]; then
            # Create structured prompt for Claude
            PROMPT="ü§ñ **Autonomous Task Completion Session** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## üìã **Task Instructions**
          Please analyze and complete the following GitHub issues autonomously:
          
          $(jq -r '.[] | "### Issue #\(.number): \(.title)\n**URL:** \(.url)\n**Labels:** \(.labels | map(.name) | join(", "))\n**Description:**\n\(.body)\n---\n"' issues.json)
          
          ## üéØ **Completion Criteria**
          For each issue:
          1. **Analyze** the requirements and technical scope
          2. **Implement** the solution following our coding standards  
          3. **Test** the implementation thoroughly
          4. **Document** any significant changes
          5. **Close** the issue with a comprehensive summary
          
          ## ‚öôÔ∏è **Technical Guidelines**
          - Follow existing code patterns and architecture
          - Add sophisticated emoji to enhance readability
          - Ensure accessibility and performance standards
          - Run tests and fix any failures
          - Use TodoWrite tool to track progress
          - Commit changes with descriptive messages
          
          ## üöÄ **Execution Priority**
          - Focus on **highest priority** issues first
          - Group **related issues** for efficient implementation
          - **Skip** any issue that seems too complex for autonomous completion
          - **Document** any issues requiring human intervention
          
          ## üìä **Success Metrics**
          - Issues successfully implemented and closed
          - Tests passing and code quality maintained
          - Clear documentation and commit messages
          - Proper issue closure with comprehensive summaries
          
          Begin autonomous task completion now. Use your best judgment for technical decisions and implementation approaches."
          
            echo "prompt<<EOF" >> $GITHUB_OUTPUT
            echo "$PROMPT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "prompt=No eligible issues found for autonomous completion." >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: üöÄ Begin Autonomous Session
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "ü§ñ **AUTONOMOUS SESSION STARTING**"
          echo "üìÖ Session #${{ steps.token-check.outputs.session_number }}/6 at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "üéØ Processing ${{ steps.fetch-issues.outputs.issue_count }} issues with priority: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "üí∞ Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo "üìä Estimated usage: ${{ steps.token-check.outputs.estimated_usage }} tokens"
          echo ""
          echo "üìã **Issues to be processed:**"
          jq -r '.[] | "  #\(.number): \(.title) (\(.labels | map(.name) | join(", ")))"' issues.json
          echo ""
          echo "üöÄ **Launching Claude Code autonomous execution...**"

      - name: üì¶ Setup Node.js for Custom Executor
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üöÄ Install Custom Executor Dependencies
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "üì¶ **INSTALLING CUSTOM EXECUTOR DEPENDENCIES**"
          cd .github/scripts
          npm install
          cd ../..
          echo "‚úÖ Dependencies installed"

      - name: ü§ñ Run Autonomous Processing
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        id: claude-autonomous
        continue-on-error: true
        run: |
          echo "ü§ñ **LAUNCHING AUTONOMOUS PROCESSING**"
          echo "üìã Processing ${{ steps.fetch-issues.outputs.issue_count }} issues"
          echo "üéØ Session #${{ steps.token-check.outputs.session_number }}/6"
          echo "üí∞ Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo ""
          
          # Check if Claude OAuth token or Anthropic API key is available
          if [ -n "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
            echo "üß† **USING CLAUDE AI AUTONOMOUS EXECUTOR (OAuth)**"
            echo "‚úÖ Claude Max OAuth token detected - full AI-powered automation enabled"
          elif [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "üß† **USING CLAUDE AI AUTONOMOUS EXECUTOR (API Key)**"
            echo "‚úÖ API key detected - full AI-powered automation enabled"
            echo ""
            
            # Create enhanced prompt file to avoid shell parsing issues
            cat > enhanced_prompt.txt << 'PROMPT_EOF'
          ü§ñ **AUTONOMOUS EXECUTION SESSION** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## üìä **Session Context**
          - Session #${{ steps.token-check.outputs.session_number }}/6
          - Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining
          - Target usage: ${{ steps.token-check.outputs.estimated_usage }} tokens
          - Issues to process: ${{ steps.fetch-issues.outputs.issue_count }}
          
          ## üéØ **Enhanced Instructions**
          ${{ steps.fetch-issues.outputs.prompt }}
          
          ## ‚ö° **Efficiency Guidelines**
          - Use prompt caching extensively for repeated contexts
          - Implement efficient, focused solutions  
          - Prioritize high-impact, low-complexity tasks when token budget is limited
          - Track and report: input_tokens, output_tokens for analysis
          
          ## üîß **Technical Excellence**
          - Follow existing code patterns and architecture
          - Use sophisticated emoji for enhanced readability
          - Run tests and ensure code quality
          - Create comprehensive issue closure summaries
          - Commit changes with descriptive messages
          
          Execute with confidence and technical excellence!
          PROMPT_EOF
            
            # Execute OAuth-compatible autonomous script
            AUTONOMOUS_PROMPT="$(cat enhanced_prompt.txt)" ISSUES_JSON="$(cat issues.json)" node .github/scripts/claude-oauth-executor.js
          else
            echo "üîß **USING RULE-BASED ISSUE PROCESSOR**"
            echo "üí° No API key - using intelligent automation without external APIs"
            echo ""
            
            # Execute rule-based issue processor
            ISSUES_JSON="$(cat issues.json)" node .github/scripts/issue-processor.js
          fi
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUTONOMOUS_PROMPT: ${{ steps.fetch-issues.outputs.prompt }}
          ISSUES_JSON: ${{ steps.fetch-issues.outputs.issues }}

      - name: ‚ö†Ô∏è Autonomous Processing Failed - Detailed Analysis
        if: steps.claude-autonomous.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è **AUTONOMOUS PROCESSING FAILED - DETAILED ERROR ANALYSIS**"
          echo "================================================="
          echo ""
          
          # Capture and display exit code details
          AUTONOMOUS_EXIT_CODE="${{ steps.claude-autonomous.outputs.exit_code || 'unknown' }}"
          echo "üîç **Exit Code**: $AUTONOMOUS_EXIT_CODE"
          echo ""
          
          # Authentication method diagnosis
          echo "üîê **Authentication Analysis**:"
          if [ -n "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ]; then
            echo "  ‚úÖ Claude OAuth Token: Present (Claude Max/Pro account)"
            echo "  üìã Account Type: ${{ steps.token-check.outputs.auth_method }}"
            echo "  üéØ Usage Limit: ${{ steps.token-check.outputs.prompts_remaining || 'Unknown' }} prompts remaining in session"
          elif [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  ‚úÖ Anthropic API Key: Present"
            echo "  üìã Account Type: ${{ steps.token-check.outputs.auth_method }}"
            echo "  üéØ Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} tokens remaining"
          else
            echo "  ‚ùå No authentication detected"
            echo "  üìã Fallback Mode: Rule-based issue processor only"
          fi
          echo ""
          
          # Issue processing context
          echo "üéØ **Issue Processing Context**:"
          echo "  üìä Issues Found: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "  üè∑Ô∏è Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "  üìã Max Issues Setting: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues }}"
          echo ""
          
          # List specific issues that failed
          echo "üìã **Issues That Failed Processing**:"
          if [ -f "issues.json" ]; then
            jq -r '.[] | "  üî∏ Issue #\(.number): \(.title)\n    üîó URL: \(.url)\n    üè∑Ô∏è Labels: \(.labels | map(.name) | join(", "))\n"' issues.json
          else
            echo "  ‚ùå issues.json not found - issue fetching may have failed"
          fi
          echo ""
          
          # Check for specific error patterns
          echo "üîç **Error Pattern Analysis**:"
          
          # Check if it's a dependency issue
          if ! command -v node &> /dev/null; then
            echo "  ‚ùå Node.js not available - dependency missing"
          else
            echo "  ‚úÖ Node.js available: $(node --version)"
          fi
          
          # Check script accessibility
          if [ ! -f ".github/scripts/claude-oauth-executor.js" ]; then
            echo "  ‚ùå OAuth executor script missing"
          else
            echo "  ‚úÖ OAuth executor script present"
          fi
          
          if [ ! -f ".github/scripts/issue-processor.js" ]; then
            echo "  ‚ùå Issue processor script missing"
          else
            echo "  ‚úÖ Issue processor script present"
          fi
          
          # Check npm dependencies
          if [ ! -f ".github/scripts/package.json" ]; then
            echo "  ‚ö†Ô∏è package.json missing in scripts directory"
          else
            echo "  ‚úÖ package.json present"
            if [ ! -d ".github/scripts/node_modules" ]; then
              echo "  ‚ùå node_modules not installed"
            else
              echo "  ‚úÖ node_modules installed"
            fi
          fi
          echo ""
          
          # Network and API diagnostics
          echo "üåê **Network & API Diagnostics**:"
          if [ -n "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ] || [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  üîç Testing Anthropic API connectivity..."
            if curl -s --max-time 10 https://api.anthropic.com > /dev/null; then
              echo "  ‚úÖ Anthropic API endpoint reachable"
            else
              echo "  ‚ùå Anthropic API endpoint unreachable"
            fi
          else
            echo "  ‚ÑπÔ∏è No API authentication - network check skipped"
          fi
          echo ""
          
          # Suggested remediation steps
          echo "üîß **Suggested Remediation Steps**:"
          echo "  1. üìã Check GitHub Actions logs above for specific error messages"
          echo "  2. üîç Verify authentication tokens are properly configured in repository secrets"
          echo "  3. üß™ Test autonomous scripts locally with: cd .github/scripts && npm test"
          echo "  4. üìä Check usage limits for your account type (Max/Pro vs API)"
          echo "  5. üîÑ Try manual workflow dispatch with different parameters"
          echo "  6. üìû If issues persist, check Anthropic service status"
          echo ""
          
          # Save failure context for analysis
          echo "üíæ **Saving Failure Context**:"
          mkdir -p .github/data/failure-logs
          FAILURE_LOG=".github/data/failure-logs/failure-$(date +%Y%m%d-%H%M%S).json"
          cat > "$FAILURE_LOG" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "trigger": "${{ github.event_name }}",
            "auth_method": "${{ steps.token-check.outputs.auth_method }}",
            "exit_code": "$AUTONOMOUS_EXIT_CODE",
            "issues_count": "${{ steps.fetch-issues.outputs.issue_count }}",
            "priority_filter": "${{ steps.fetch-issues.outputs.actual_priority }}",
            "workflow_run_id": "${{ github.run_id }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.sha }}"
          }
          EOF
          echo "  üìÑ Failure context saved to: $FAILURE_LOG"
          echo ""
          
          echo "================================================="
          echo "üîç **For detailed logs, check the workflow run at:**"
          echo "üîó https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: üìä Autonomous Session Complete
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          echo "üèÅ **AUTONOMOUS SESSION COMPLETED**"
          echo "üìÖ Finished at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "‚úÖ Session outcome: ${{ steps.claude-autonomous.outcome }}"
          echo "üéØ Issues processed: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "üìä Priority level: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo ""

      - name: üíæ Record Usage Analytics (Max/Pro Compatible)
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          # Record session usage based on account type
          USAGE_FILE=".github/data/usage-tracking.json"
          SESSION_TIME=$(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          SESSION_UTC=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          AUTH_METHOD="${{ steps.token-check.outputs.auth_method }}"
          
          echo "üîç Debug: AUTH_METHOD is: $AUTH_METHOD"
          echo "üîç Debug: OAuth token present: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN != '' }}"
          echo "üîç Debug: API key present: ${{ secrets.ANTHROPIC_API_KEY != '' }}"
          
          # Ensure usage file exists with proper structure
          mkdir -p .github/data
          if [ ! -f "$USAGE_FILE" ]; then
            echo "üìÅ Creating new usage tracking file"
            jq -n \
              --arg auth_method "$AUTH_METHOD" \
              --arg last_reset "$SESSION_UTC" \
              --arg created "$SESSION_UTC" \
              '{
                "auth_method": $auth_method,
                "session_usage": [],
                "five_hour_sessions": [],
                "last_session_reset": $last_reset,
                "metadata": {
                  "max_pro_limits": {
                    "pro_prompts_per_5h": 40,
                    "max_5x_prompts_per_5h": 200,
                    "max_20x_prompts_per_5h": 800,
                    "session_length_hours": 5
                  },
                  "api_limits": {
                    "daily_tokens": 100000,
                    "free_tier_tokens": 25000,
                    "paid_tier_tokens": 200000
                  },
                  "created": $created,
                  "version": "2.1"
                }
              }' > "$USAGE_FILE"
          fi
          
          # Record usage based on authentication method
          if [ "$AUTH_METHOD" = "claude-max-oauth" ]; then
            # Max/Pro account - record prompt usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              PROMPTS_USED=3  # Conservative estimate for successful run
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              PROMPTS_USED=1  # Partial execution
            else
              PROMPTS_USED=0  # Skipped
            fi
            
            echo "üìä Max/Pro Usage Recording:"
            echo "- Prompts Used: $PROMPTS_USED"
            echo "- Session Outcome: ${{ steps.claude-autonomous.outcome }}"
            echo "- Issues Processed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with prompt-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values for empty variables
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            PROMPTS_USED="${PROMPTS_USED:-0}"
            
            echo "üîç Debug: Variables before jq:"
            echo "  SESSION_TIME: $SESSION_TIME"
            echo "  SESSION_UTC: $SESSION_UTC"
            echo "  PROMPTS_USED: $PROMPTS_USED"
            echo "  OUTCOME: $OUTCOME"
            echo "  ISSUE_COUNT: $ISSUE_COUNT"
            echo "  AUTH_METHOD: $AUTH_METHOD"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg prompts "$PROMPTS_USED" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .five_hour_sessions += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }] |
                   .session_usage += [{
                     "timestamp": $time,
                     "type": "claude_max_pro",
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_count": ($issues | tonumber)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, attempting manual JSON creation"
              # Fallback to manual JSON creation if jq fails
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
              echo "‚ö†Ô∏è Usage tracking update failed, keeping original file"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
            
          elif [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API account - estimate token usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              TOTAL_TOKENS=5000  # Conservative estimate
              CACHE_HIT_RATIO=0.65
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              TOTAL_TOKENS=2500  # Partial execution
              CACHE_HIT_RATIO=0.3
            else
              TOTAL_TOKENS=0
              CACHE_HIT_RATIO=0
            fi
            
            CACHED_TOKENS=$((TOTAL_TOKENS * 65 / 100))
            INPUT_TOKENS=$((TOTAL_TOKENS * 60 / 100))
            OUTPUT_TOKENS=$((TOTAL_TOKENS * 40 / 100))
            TOKEN_SAVINGS=$((CACHED_TOKENS * 75 / 100))
            
            echo "üìä API Token Usage Recording:"
            echo "- Total Tokens: $TOTAL_TOKENS"
            echo "- Cached Tokens: $CACHED_TOKENS"
            echo "- Token Savings: $TOKEN_SAVINGS"
            
            # Update usage file with token-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
            
          else
            # No auth - record rule-based processing
            echo "üìä Rule-based Processing Recording:"
            echo "- Mode: API-free issue analysis"
            echo "- Issues Analyzed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with rule-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "type": "rule_based",
                     "outcome": $outcome,
                     "issues_analyzed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
          fi
          
          # Update comprehensive usage tracking with cache analytics (if variables available)
          if [ -n "$TOTAL_TOKENS" ] && [ -n "$SESSION_TIME" ]; then
            FINAL_OUTCOME="${{ steps.claude-autonomous.outcome }}"
            FINAL_ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            FINAL_SESSION_NUMBER="${{ steps.token-check.outputs.session_number }}"
            
            # Provide fallback values
            FINAL_OUTCOME="${FINAL_OUTCOME:-unknown}"
            FINAL_ISSUE_COUNT="${FINAL_ISSUE_COUNT:-0}"
            FINAL_SESSION_NUMBER="${FINAL_SESSION_NUMBER:-1}"
            
            # Skip comprehensive tracking if basic values are missing
            if [ -z "$TOTAL_TOKENS" ]; then
              TOTAL_TOKENS=0
              INPUT_TOKENS=0
              OUTPUT_TOKENS=0
              CACHED_TOKENS=0
              TOKEN_SAVINGS=0
              CACHE_HIT_RATIO=0
            fi
            
            # Update comprehensive usage tracking with error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$FINAL_OUTCOME" \
                   --arg issues "$FINAL_ISSUE_COUNT" \
                   --arg session "$FINAL_SESSION_NUMBER" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "session_number": ($session | tonumber),
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber)
                   }] |
                   .daily_usage += [{
                     "hour": ($time | split(" ")[1] | split(":")[0] | tonumber),
                     "total_tokens": ($total | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "token_savings": ($savings | tonumber)
                   }] |
                   .cache_efficiency += [{
                     "timestamp": $utc,
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "tokens_saved": ($savings | tonumber),
                     "efficiency_score": (if ($total | tonumber) > 0 then (($savings | tonumber) / ($total | tonumber)) else 0 end)
                   }] |
                   .token_savings += [{
                     "timestamp": $utc,
                     "session": ($session | tonumber),
                     "base_cost": ($total | tonumber),
                     "actual_cost": (($total | tonumber) - ($savings | tonumber)),
                     "savings": ($savings | tonumber),
                     "savings_percentage": (if ($total | tonumber) > 0 then ((($savings | tonumber) / ($total | tonumber)) * 100) else 0 end)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå Comprehensive tracking failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Comprehensive usage tracking updated"
            fi
          else
            echo "‚ö†Ô∏è Skipping comprehensive tracking due to missing variables"
          fi
          
          echo "üìä Token Usage Analytics:"
          echo "- Total Tokens: $TOTAL_TOKENS"
          echo "- Input Tokens: $INPUT_TOKENS"
          echo "- Output Tokens: $OUTPUT_TOKENS" 
          echo "- Cached Tokens: $CACHED_TOKENS"
          echo "- Cache Hit Ratio: $(echo "$CACHE_HIT_RATIO * 100" | bc -l | cut -d. -f1)%"
          echo "- Token Savings: $TOKEN_SAVINGS"
          echo "- Cost Efficiency: $(echo "scale=1; $TOKEN_SAVINGS * 100 / $TOTAL_TOKENS" | bc -l)%"
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìä Autonomous Session Summary
        if: always()
        run: |
          echo "ü§ñ **Autonomous Task Completion Summary** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo ""
          echo "**Session Metrics:**"
          echo "- Session: #${{ steps.token-check.outputs.session_number || 'N/A' }}/6"
          echo "- Issues Available: ${{ steps.fetch-issues.outputs.issue_count || 'N/A' }}"
          echo "- Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}"
          echo "- Max Issues: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues || '3' }}"
          echo "- Trigger: ${{ github.event_name == 'schedule' && 'Scheduled (4-hour cycle)' || 'Manual dispatch' }}"
          echo "- Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} remaining"
          echo "- Estimated Usage: ${{ steps.token-check.outputs.estimated_usage || 'Unknown' }} tokens"
          
          # Display cache efficiency summary if usage file exists
          if [ -f ".github/data/token-usage.json" ]; then
            echo ""
            echo "üìà **Token Analytics Summary:**"
            TOTAL_SAVED=$(jq '.token_savings | map(.savings) | add // 0' .github/data/token-usage.json)
            TOTAL_SPENT=$(jq '.session_usage | map(.total_tokens) | add // 0' .github/data/token-usage.json)
            AVG_CACHE_RATIO=$(jq '.cache_efficiency | if length > 0 then map(.cache_hit_ratio) | add / length else 0 end' .github/data/token-usage.json)
            echo "- Total Tokens Saved: $TOTAL_SAVED"
            echo "- Total Tokens Spent: $TOTAL_SPENT"
            echo "- Average Cache Hit Ratio: $(echo "scale=1; $AVG_CACHE_RATIO * 100" | bc -l)%"
            echo "- Overall Efficiency: $(echo "scale=1; $TOTAL_SAVED * 100 / ($TOTAL_SPENT + $TOTAL_SAVED)" | bc -l)%"
          fi
          echo ""
          
          if [ "${{ steps.token-check.outputs.proceed }}" = "false" ]; then
            echo "‚ö†Ô∏è Session skipped due to insufficient token budget"
            echo "üí° Token conservation active - will resume next cycle or tomorrow"
          elif [ "${{ steps.fetch-issues.outputs.issue_count || '0' }}" -gt 0 ]; then
            echo "‚úÖ Claude autonomous session executed successfully"
            echo "üîç Check the Claude Code action logs for detailed implementation results"
          else
            echo "‚ÑπÔ∏è No eligible issues found for autonomous completion"
            echo "üí° Issues may be labeled as draft, wip, blocked, or no high-priority items available"
          fi
          
          echo ""
          echo "**Next autonomous session:** $(TZ='Australia/Sydney' date -d '+4 hours' +'%Y-%m-%d %H:%M AEST')"

      - name: üîî Notify on Completion
        if: always() && (steps.fetch-issues.outputs.issue_count > 0 || steps.token-check.outputs.proceed == 'false')
        run: |
          # Create a workflow summary
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ü§ñ Autonomous Task Completion Results
          
          **Session:** $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST') (#${{ steps.token-check.outputs.session_number }}/6)  
          **Issues Processed:** ${{ steps.fetch-issues.outputs.issue_count || '0' }}  
          **Priority Level:** ${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}  
          **Token Budget:** ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} remaining  
          **Estimated Usage:** ${{ steps.token-check.outputs.estimated_usage || 'Unknown' }} tokens
          
          ### üìà Token Analytics:
          $(cat .github/data/token-usage.json 2>/dev/null | jq -r '
            "**Total Sessions Today:** " + (.session_usage | length | tostring) + "/6" + "\n" +
            "**Tokens Spent Today:** " + (.daily_usage | map(.total_tokens) | add // 0 | tostring) + "\n" +
            "**Tokens Saved (Cache):** " + (.daily_usage | map(.token_savings) | add // 0 | tostring) + "\n" +
            "**Average Cache Hit Ratio:** " + ((.cache_efficiency | map(.cache_hit_ratio) | add / length // 0) * 100 | floor | tostring) + "%" + "\n" +
            "**Cost Efficiency:** " + ((.token_savings | map(.savings_percentage) | add / length // 0) | floor | tostring) + "% savings"
          ' || echo "**Analytics:** Not available yet")
          
          ### üìã Issues Targeted:
          $(if [ -f "issues.json" ]; then jq -r '.[] | "- **#\(.number):** \(.title)"' issues.json; else echo "No issues found for processing"; fi)
          
          ### ‚úÖ Results:
          ${{ steps.token-check.outputs.proceed == 'false' && '‚ö†Ô∏è **Session skipped** due to insufficient token budget. Will resume when tokens are available.' || 'Check the [Claude Code Action logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed implementation results and issue closure summaries.' }}
          
          ### ‚è∞ Next Session:
          The next autonomous session will run in 4 hours at: **$(TZ='Australia/Sydney' date -d '+4 hours' +'%Y-%m-%d %H:%M AEST')**
          
          ### üìä Token Usage Trends:
          $(cat .github/data/token-usage.json 2>/dev/null | jq -r '
            if (.session_usage | length) > 0 then
              "**Recent Sessions:**\n" +
              (.session_usage | reverse | .[0:3] | map(
                "- " + .timestamp + ": " + (.total_tokens | tostring) + " tokens (" + (.cache_hit_ratio * 100 | floor | tostring) + "% cached, " + (.token_savings | tostring) + " saved)"
              ) | join("\n"))
            else
              "No session data available yet."
            end
          ' || echo "Analytics data will be available after first session.")
          EOF