name: ü§ñ Autonomous Task Completion

# üéØ **WORKFLOW OVERVIEW**
# This workflow provides automated issue processing using Claude AI with sophisticated
# token management, priority filtering, and comprehensive analytics tracking.
# 
# üîÑ **EXECUTION SCHEDULE**: Every 6 hours (00:00, 06:00, 12:00, 18:00 AEST)
# üìä **TOKEN OPTIMIZATION**: Intelligent caching and usage prediction
# üéØ **PRIORITY HANDLING**: Dynamic fallback from high‚Üímedium‚Üílow priority
# üìà **ANALYTICS**: Comprehensive token usage and cache efficiency tracking
# 
# üîß **CONFIGURATION**:
# - Supports both API key and OAuth authentication methods
# - Automatic tier detection (free/paid) with appropriate limits
# - Intelligent session management for Max/Pro accounts
# - Robust error handling and detailed failure analysis
# 
# üìã **WORKFLOW STEPS**:
# 1. Usage history analysis and limit validation
# 2. Repository checkout and issue fetching with priority filtering
# 3. Autonomous Claude processing with enhanced prompting
# 4. Comprehensive usage tracking and analytics
# 5. Detailed session summaries and next-session scheduling

on:
  schedule:
    # üïê Run every 6 hours starting at midnight AEST (14:00 UTC) 
    # Schedule: 00:00, 06:00, 12:00, 18:00 AEST daily
    # This provides 4 processing windows per day for comprehensive autonomous task completion
    - cron: '0 14,20,2,8 * * *'
  workflow_dispatch:
    inputs:
      max_issues:
        description: 'üìä Maximum number of issues to process per session'
        required: false
        default: '1'
        type: string
      generate_report:
        description: 'üìà Generate detailed token usage and analytics report'
        required: false
        default: true
        type: boolean
      priority_filter:
        description: 'üéØ Priority filter with automatic fallback (critical‚Üíhigh‚Üímedium‚Üílow)'
        required: false
        default: 'critical'
        type: choice
        options:
          - critical
          - high
          - medium 
          - low
          - all

jobs:
  autonomous-tasks:
    # üñ•Ô∏è **JOB CONFIGURATION**
    # Runs on latest Ubuntu with comprehensive GitHub permissions for:
    # - Repository content modification (contents: write)
    # - Pull request creation and management (pull-requests: write) 
    # - Issue processing and closure (issues: write)
    # - OIDC token generation for secure authentication (id-token: write)
    # - Workflow run analysis and reporting (actions: read)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read

    steps:
      # üìä **STEP 1: USAGE ANALYSIS & LIMIT VALIDATION**
      # Comprehensive token usage tracking compatible with both Claude Max/Pro accounts
      # and Anthropic API keys. Implements intelligent tier detection, session boundary
      # management, and automatic limit calculation based on usage patterns.
      - name: üìä Check Usage History (Max/Pro Compatible)
        id: token-check
        run: |
          # Create usage tracking file with Max/Pro account compatibility
          mkdir -p .github/data
          USAGE_FILE=".github/data/usage-tracking.json"
          
          # Detect authentication method for proper limit calculation
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            AUTH_METHOD="anthropic-api"
            echo "üîê Detected Anthropic API key authentication"
          else
            AUTH_METHOD="none"
            echo "üîß No authentication - using rule-based processing"
          fi
          
          if [ ! -f "$USAGE_FILE" ]; then
            echo '{
              "auth_method": "'$AUTH_METHOD'",
              "session_usage": [],
              "five_hour_sessions": [],
              "last_session_reset": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "metadata": {
                "max_pro_limits": {
                  "pro_prompts_per_5h": 40,
                  "max_5x_prompts_per_5h": 200,
                  "max_20x_prompts_per_5h": 800,
                  "session_length_hours": 5
                },
                "api_limits": {
                  "daily_tokens": 100000
                },
                "created": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                "version": "2.0"
              }
            }' > "$USAGE_FILE"
          fi
          
          # Calculate 5-hour session boundaries for Max/Pro accounts
          CURRENT_TIME=$(date -u +%s)
          LAST_SESSION_TIME=$(date -d "$(jq -r '.last_session_reset' "$USAGE_FILE")" +%s 2>/dev/null || echo "0")
          FIVE_HOURS_AGO=$((CURRENT_TIME - 18000)) # 5 hours = 18000 seconds
          
          # Check if we need to reset 5-hour session for Max/Pro
          if [ "$AUTH_METHOD" = "claude-max-oauth" ] && [ "$LAST_SESSION_TIME" -lt "$FIVE_HOURS_AGO" ]; then
            echo "üîÑ Resetting 5-hour session limits for Claude Max/Pro account"
            jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '.
              | .five_hour_sessions = []
              | .last_session_reset = $timestamp' "$USAGE_FILE" > "$USAGE_FILE.tmp"
            mv "$USAGE_FILE.tmp" "$USAGE_FILE"
          fi
          
          # Calculate usage limits based on authentication method
          if [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API key - token-based daily limits (detect tier based on usage patterns)
            TOKENS_USED_TODAY=$(jq '.session_usage | map(.total_tokens // 0) | add // 0' "$USAGE_FILE")
            
            # Detect API tier based on typical usage patterns and set appropriate limits
            # Free tier: ~25k tokens/day, Paid tier: ~100k+ tokens/day
            if [ "$TOKENS_USED_TODAY" -gt 50000 ] || [ -n "${{ github.event.inputs.force_paid_tier }}" ]; then
              DAILY_TOKENS=200000  # Paid tier - more generous limit
              API_TIER="paid"
              MIN_TOKENS=10000     # Higher threshold for paid accounts
            else
              DAILY_TOKENS=25000   # Free tier - conservative limit
              API_TIER="free"
              MIN_TOKENS=2000      # Lower threshold for free accounts
            fi
            
            TOKENS_REMAINING=$((DAILY_TOKENS - TOKENS_USED_TODAY))
            
            echo "üìä Anthropic API Usage Analysis:"
            echo "- Account Type: API Key ($API_TIER tier)"
            echo "- Daily Limit: $DAILY_TOKENS tokens"
            echo "- Used Today: $TOKENS_USED_TODAY tokens"
            echo "- Remaining: $TOKENS_REMAINING tokens"
            echo "- Minimum Required: $MIN_TOKENS tokens"
            
            if [ "$TOKENS_REMAINING" -lt "$MIN_TOKENS" ]; then
              echo "‚ö†Ô∏è Insufficient token budget remaining for $API_TIER tier"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "limit_reason=token_limit" >> $GITHUB_OUTPUT
            elif [ "$API_TIER" = "free" ] && [ "$TOKENS_REMAINING" -lt 10000 ]; then
              echo "üí° Limited tokens remaining on free tier, reducing scope"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=1" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Sufficient tokens available for $API_TIER tier"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=$( [ "$API_TIER" = "free" ] && echo "2" || echo "3" )" >> $GITHUB_OUTPUT
            fi
            
            # Set estimated usage based on tier and remaining tokens
            ESTIMATED_USAGE=$( [ "$API_TIER" = "free" ] && echo "3000" || echo "8000" )
            echo "estimated_usage=$ESTIMATED_USAGE" >> $GITHUB_OUTPUT
            echo "tokens_remaining=$TOKENS_REMAINING" >> $GITHUB_OUTPUT
            echo "api_tier=$API_TIER" >> $GITHUB_OUTPUT
            
          else
            # No authentication - always proceed with rule-based processing
            echo "üìä Rule-based Processing (No API limits):"
            echo "- Mode: Issue analysis and suggestions only"
            echo "- No external API calls required"
            echo "‚úÖ Always available for rule-based automation"
            
            echo "proceed=true" >> $GITHUB_OUTPUT
            echo "max_issues=5" >> $GITHUB_OUTPUT
            echo "estimated_usage=none" >> $GITHUB_OUTPUT
            echo "limit_reason=none" >> $GITHUB_OUTPUT
            echo "tokens_remaining=unlimited" >> $GITHUB_OUTPUT  # For compatibility
          fi
          
          echo "auth_method=$AUTH_METHOD" >> $GITHUB_OUTPUT
          echo "session_number=1" >> $GITHUB_OUTPUT
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üöÄ Checkout Repository  
        if: steps.token-check.outputs.proceed == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Fetch Open Issues
        id: fetch-issues
        if: steps.token-check.outputs.proceed == 'true'
        run: |
          # Fetch open issues with specific labels and priorities
          PRIORITY_FILTER="${{ github.event.inputs.priority_filter || 'high' }}"
          MAX_ISSUES="${{ github.event.inputs.max_issues || steps.token-check.outputs.max_issues || '3' }}"
          
          # Build label filter with fallback priority strategy
          echo "üîç Searching for issues with priority: $PRIORITY_FILTER"
          
          if [ "$PRIORITY_FILTER" = "all" ]; then
            echo "üìã Using no priority filter - checking all open issues"
          else
            echo "üéØ Filtering for \"priority: ${PRIORITY_FILTER}\" issues"
          fi
          
          # Fetch issues (excluding draft, wip, blocked)
          echo "üì• Fetching open issues..."
          if [ "$PRIORITY_FILTER" = "all" ]; then
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --json number,title,labels,body,url > all_issues.json
          else
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: ${PRIORITY_FILTER}" \
              --json number,title,labels,body,url > all_issues.json
          fi
          
          # Filter out draft, wip, blocked issues
          jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues.json > issues.json
          
          # Debug: Show what we fetched
          echo "üîç Debug: Issues fetched from GitHub:"
          cat all_issues.json | jq length
          echo "üîç Debug: Issues after filtering:"
          cat issues.json | jq length
          
          # Get count with error handling
          ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
          echo "üìä Found $ISSUE_COUNT issues with priority:${PRIORITY_FILTER}"
          
          # Ensure ISSUE_COUNT is a valid integer
          if [ -z "$ISSUE_COUNT" ] || ! [[ "$ISSUE_COUNT" =~ ^[0-9]+$ ]]; then
            ISSUE_COUNT="0"
          fi
          
          # If no high priority issues found, try medium priority
          if [ "$ISSUE_COUNT" -eq 0 ] && [ "$PRIORITY_FILTER" = "high" ]; then
            echo "‚¨áÔ∏è No high priority issues found, falling back to medium priority..."
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: medium" \
              --json number,title,labels,body,url > all_issues_medium.json
            
            # Filter out draft, wip, blocked issues
            jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues_medium.json > issues.json
            
            ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
            echo "üìä Found $ISSUE_COUNT medium priority issues"
            PRIORITY_FILTER="medium (fallback)"
          fi
          
          echo "‚úÖ Final issue count: $ISSUE_COUNT eligible issues for processing"
          echo "issue_count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
          echo "actual_priority=$PRIORITY_FILTER" >> $GITHUB_OUTPUT
          
          if [ "$ISSUE_COUNT" -gt 0 ]; then
            # Create structured prompt for Claude
            PROMPT="ü§ñ **Autonomous Task Completion Session** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## üìã **Task Instructions**
          Please analyze and complete the following GitHub issues autonomously:
          
          $(jq -r '.[] | "### Issue #\(.number): \(.title)\n**URL:** \(.url)\n**Labels:** \(.labels | map(.name) | join(", "))\n**Description:**\n\(.body)\n---\n"' issues.json)
          
          ## üéØ **Completion Criteria**
          For each issue:
          1. **Analyze** the requirements and technical scope
          2. **Implement** the solution following our coding standards  
          3. **Test** the implementation thoroughly
          4. **Document** any significant changes
          5. **Close** the issue with a comprehensive summary
          
          ## ‚öôÔ∏è **Technical Guidelines**
          - Follow existing code patterns and architecture
          - Add sophisticated emoji to enhance readability
          - Ensure accessibility and performance standards
          - Run tests and fix any failures
          - Use TodoWrite tool to track progress
          - Commit changes with descriptive messages
          
          ## üöÄ **Execution Priority**
          - Focus on **highest priority** issues first
          - Group **related issues** for efficient implementation
          - **Skip** any issue that seems too complex for autonomous completion
          - **Document** any issues requiring human intervention
          
          ## üìä **Success Metrics**
          - Issues successfully implemented and closed
          - Tests passing and code quality maintained
          - Clear documentation and commit messages
          - Proper issue closure with comprehensive summaries
          
          Begin autonomous task completion now. Use your best judgment for technical decisions and implementation approaches."
          
            echo "prompt<<EOF" >> $GITHUB_OUTPUT
            echo "$PROMPT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "prompt=No eligible issues found for autonomous completion." >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: üöÄ Begin Autonomous Session
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "ü§ñ **AUTONOMOUS SESSION STARTING**"
          echo "üìÖ Session #${{ steps.token-check.outputs.session_number }}/4 at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "üéØ Processing ${{ steps.fetch-issues.outputs.issue_count }} issues with priority: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "üí∞ Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo "üìä Estimated usage: ${{ steps.token-check.outputs.estimated_usage }} tokens"
          echo ""
          echo "üìã **Issues to be processed:**"
          jq -r '.[] | "  #\(.number): \(.title) (\(.labels | map(.name) | join(", ")))"' issues.json
          echo ""
          echo "üöÄ **Launching Claude Code autonomous execution...**"

      - name: üì¶ Setup Node.js for Custom Executor
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üöÄ Install Custom Executor Dependencies
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "üì¶ **INSTALLING CUSTOM EXECUTOR DEPENDENCIES**"
          cd .github/scripts
          npm install
          cd ../..
          echo "‚úÖ Dependencies installed"

      - name: ü§ñ Run Autonomous Processing
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        id: claude-autonomous
        run: |
          echo "ü§ñ **LAUNCHING AUTONOMOUS PROCESSING**"
          echo "üìã Processing ${{ steps.fetch-issues.outputs.issue_count }} issues"
          echo "üéØ Session #${{ steps.token-check.outputs.session_number }}/4"
          echo "üí∞ Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo ""
          
          # Check API key first (currently supported), then OAuth (future support)
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "üß† **USING CLAUDE AI AUTONOMOUS EXECUTOR (API Key)**"
            echo "‚úÖ Anthropic API key detected - full AI-powered automation enabled"
            echo ""
            
            # Create enhanced prompt file to avoid shell parsing issues
            cat > enhanced_prompt.txt << 'PROMPT_EOF'
          ü§ñ **AUTONOMOUS EXECUTION SESSION** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## üìä **Session Context**
          - Session #${{ steps.token-check.outputs.session_number }}/4
          - Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining
          - Target usage: ${{ steps.token-check.outputs.estimated_usage }} tokens
          - Issues to process: ${{ steps.fetch-issues.outputs.issue_count }}
          
          ## üéØ **Enhanced Instructions**
          ${{ steps.fetch-issues.outputs.prompt }}
          
          ## ‚ö° **Efficiency Guidelines**
          - Use prompt caching extensively for repeated contexts
          - Implement efficient, focused solutions  
          - Prioritize high-impact, low-complexity tasks when token budget is limited
          - Track and report: input_tokens, output_tokens for analysis
          
          ## üîß **Technical Excellence**
          - Follow existing code patterns and architecture
          - Use sophisticated emoji for enhanced readability
          - Comprehensive issue closure summaries with proper emoji
          - Test implementations before closing issues
          - Proper issue closure with comprehensive summaries
          
          Begin autonomous task completion now. Use your best judgment for technical decisions and implementation approaches.
          PROMPT_EOF
            
            # Execute OAuth-compatible autonomous script (API key fallback)
            AUTONOMOUS_PROMPT="$(cat enhanced_prompt.txt)" ISSUES_JSON="$(cat issues.json)" node .github/scripts/claude-oauth-executor.js
          else
            echo "üîß **USING RULE-BASED ISSUE PROCESSOR**"
            echo "üí° No API key - using intelligent automation without external APIs"
            echo ""
            
            # Execute rule-based issue processor
            ISSUES_JSON="$(cat issues.json)" node .github/scripts/issue-processor.js
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUTONOMOUS_PROMPT: ${{ steps.fetch-issues.outputs.prompt }}
          ISSUES_JSON: ${{ steps.fetch-issues.outputs.issues }}

      - name: ‚ö†Ô∏è Autonomous Processing Failed - Detailed Analysis
        if: steps.claude-autonomous.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è **AUTONOMOUS PROCESSING FAILED - DETAILED ERROR ANALYSIS**"
          echo "================================================="
          echo ""
          
          # Capture and display exit code details
          AUTONOMOUS_EXIT_CODE="${{ steps.claude-autonomous.outputs.exit_code || 'unknown' }}"
          echo "üîç **Exit Code**: $AUTONOMOUS_EXIT_CODE"
          echo ""
          
          # Authentication method diagnosis
          echo "üîê **Authentication Analysis**:"
          if [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  ‚úÖ Anthropic API Key: Present"
            echo "  üìã Account Type: ${{ steps.token-check.outputs.auth_method }}"
            echo "  üéØ Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} tokens remaining"
          else
            echo "  ‚ùå No authentication detected"
            echo "  üìã Fallback Mode: Rule-based issue processor only"
          fi
          echo ""
          
          # Issue processing context
          echo "üéØ **Issue Processing Context**:"
          echo "  üìä Issues Found: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "  üè∑Ô∏è Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "  üìã Max Issues Setting: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues }}"
          echo ""
          
          # List specific issues that failed
          echo "üìã **Issues That Failed Processing**:"
          if [ -f "issues.json" ]; then
            jq -r '.[] | "  üî∏ Issue #\(.number): \(.title)\n    üîó URL: \(.url)\n    üè∑Ô∏è Labels: \(.labels | map(.name) | join(", "))\n"' issues.json
          else
            echo "  ‚ùå issues.json not found - issue fetching may have failed"
          fi
          echo ""
          
          # Check for specific error patterns
          echo "üîç **Error Pattern Analysis**:"
          
          # Check if it's a dependency issue
          if ! command -v node &> /dev/null; then
            echo "  ‚ùå Node.js not available - dependency missing"
          else
            echo "  ‚úÖ Node.js available: $(node --version)"
          fi
          
          # Check script accessibility
          if [ ! -f ".github/scripts/claude-oauth-executor.js" ]; then
            echo "  ‚ùå OAuth executor script missing"
          else
            echo "  ‚úÖ OAuth executor script present"
          fi
          
          if [ ! -f ".github/scripts/issue-processor.js" ]; then
            echo "  ‚ùå Issue processor script missing"
          else
            echo "  ‚úÖ Issue processor script present"
          fi
          
          # Check npm dependencies
          if [ ! -f ".github/scripts/package.json" ]; then
            echo "  ‚ö†Ô∏è package.json missing in scripts directory"
          else
            echo "  ‚úÖ package.json present"
            if [ ! -d ".github/scripts/node_modules" ]; then
              echo "  ‚ùå node_modules not installed"
            else
              echo "  ‚úÖ node_modules installed"
            fi
          fi
          echo ""
          
          # Network and API diagnostics
          echo "üåê **Network & API Diagnostics**:"
          if [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  üîç Testing Anthropic API connectivity..."
            if curl -s --max-time 10 https://api.anthropic.com > /dev/null; then
              echo "  ‚úÖ Anthropic API endpoint reachable"
            else
              echo "  ‚ùå Anthropic API endpoint unreachable"
            fi
          else
            echo "  ‚ÑπÔ∏è No API authentication - network check skipped"
          fi
          echo ""
          
          # Suggested remediation steps
          echo "üîß **Suggested Remediation Steps**:"
          echo "  1. üìã Check GitHub Actions logs above for specific error messages"
          echo "  2. üîç Verify authentication tokens are properly configured in repository secrets"
          echo "  3. üß™ Test autonomous scripts locally with: cd .github/scripts && npm test"
          echo "  4. üìä Check usage limits for your account type (Max/Pro vs API)"
          echo "  5. üîÑ Try manual workflow dispatch with different parameters"
          echo "  6. üìû If issues persist, check Anthropic service status"
          echo ""
          
          # Save failure context for analysis
          echo "üíæ **Saving Failure Context**:"
          mkdir -p .github/data/failure-logs
          FAILURE_LOG=".github/data/failure-logs/failure-$(date +%Y%m%d-%H%M%S).json"
          cat > "$FAILURE_LOG" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "trigger": "${{ github.event_name }}",
            "auth_method": "${{ steps.token-check.outputs.auth_method }}",
            "exit_code": "$AUTONOMOUS_EXIT_CODE",
            "issues_count": "${{ steps.fetch-issues.outputs.issue_count }}",
            "priority_filter": "${{ steps.fetch-issues.outputs.actual_priority }}",
            "workflow_run_id": "${{ github.run_id }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.sha }}"
          }
          EOF
          echo "  üìÑ Failure context saved to: $FAILURE_LOG"
          echo ""
          
          echo "================================================="
          echo "üîç **For detailed logs, check the workflow run at:**"
          echo "üîó https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: üìä Autonomous Session Complete
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          echo "üèÅ **AUTONOMOUS SESSION COMPLETED**"
          echo "üìÖ Finished at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "‚úÖ Session outcome: ${{ steps.claude-autonomous.outcome }}"
          echo "üéØ Issues processed: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "üìä Priority level: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo ""

      - name: üíæ Record Usage Analytics (Max/Pro Compatible)
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          # Record session usage based on account type
          USAGE_FILE=".github/data/usage-tracking.json"
          SESSION_TIME=$(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          SESSION_UTC=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          AUTH_METHOD="${{ steps.token-check.outputs.auth_method }}"
          
          echo "üîç Debug: AUTH_METHOD is: $AUTH_METHOD"
          echo "üîç Debug: API key present: ${{ secrets.ANTHROPIC_API_KEY != '' }}"
          
          # Ensure usage file exists with proper structure
          mkdir -p .github/data
          if [ ! -f "$USAGE_FILE" ]; then
            echo "üìÅ Creating new usage tracking file"
            jq -n \
              --arg auth_method "$AUTH_METHOD" \
              --arg last_reset "$SESSION_UTC" \
              --arg created "$SESSION_UTC" \
              '{
                "auth_method": $auth_method,
                "session_usage": [],
                "five_hour_sessions": [],
                "last_session_reset": $last_reset,
                "metadata": {
                  "max_pro_limits": {
                    "pro_prompts_per_5h": 40,
                    "max_5x_prompts_per_5h": 200,
                    "max_20x_prompts_per_5h": 800,
                    "session_length_hours": 5
                  },
                  "api_limits": {
                    "daily_tokens": 100000,
                    "free_tier_tokens": 25000,
                    "paid_tier_tokens": 200000
                  },
                  "created": $created,
                  "version": "2.1"
                }
              }' > "$USAGE_FILE"
          fi
          
          # Record usage based on authentication method
          if [ "$AUTH_METHOD" = "claude-max-oauth" ]; then
            # Max/Pro account - record prompt usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              PROMPTS_USED=3  # Conservative estimate for successful run
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              PROMPTS_USED=1  # Partial execution
            else
              PROMPTS_USED=0  # Skipped
            fi
            
            echo "üìä Max/Pro Usage Recording:"
            echo "- Prompts Used: $PROMPTS_USED"
            echo "- Session Outcome: ${{ steps.claude-autonomous.outcome }}"
            echo "- Issues Processed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with prompt-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values for empty variables
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            PROMPTS_USED="${PROMPTS_USED:-0}"
            
            echo "üîç Debug: Variables before jq:"
            echo "  SESSION_TIME: $SESSION_TIME"
            echo "  SESSION_UTC: $SESSION_UTC"
            echo "  PROMPTS_USED: $PROMPTS_USED"
            echo "  OUTCOME: $OUTCOME"
            echo "  ISSUE_COUNT: $ISSUE_COUNT"
            echo "  AUTH_METHOD: $AUTH_METHOD"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg prompts "$PROMPTS_USED" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .five_hour_sessions += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }] |
                   .session_usage += [{
                     "timestamp": $time,
                     "type": "claude_max_pro",
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_count": ($issues | tonumber)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, attempting manual JSON creation"
              # Fallback to manual JSON creation if jq fails
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
              echo "‚ö†Ô∏è Usage tracking update failed, keeping original file"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
            
          elif [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API account - estimate token usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              TOTAL_TOKENS=5000  # Conservative estimate
              CACHE_HIT_RATIO=0.65
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              TOTAL_TOKENS=2500  # Partial execution
              CACHE_HIT_RATIO=0.3
            else
              TOTAL_TOKENS=0
              CACHE_HIT_RATIO=0
            fi
            
            CACHED_TOKENS=$((TOTAL_TOKENS * 65 / 100))
            INPUT_TOKENS=$((TOTAL_TOKENS * 60 / 100))
            OUTPUT_TOKENS=$((TOTAL_TOKENS * 40 / 100))
            TOKEN_SAVINGS=$((CACHED_TOKENS * 75 / 100))
            
            echo "üìä API Token Usage Recording:"
            echo "- Total Tokens: $TOTAL_TOKENS"
            echo "- Cached Tokens: $CACHED_TOKENS"
            echo "- Token Savings: $TOKEN_SAVINGS"
            
            # Update usage file with token-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
            
          else
            # No auth - record rule-based processing
            echo "üìä Rule-based Processing Recording:"
            echo "- Mode: API-free issue analysis"
            echo "- Issues Analyzed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with rule-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "type": "rule_based",
                     "outcome": $outcome,
                     "issues_analyzed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Usage tracking updated successfully"
            fi
          fi
          
          # Update comprehensive usage tracking with cache analytics (if variables available)
          if [ -n "$TOTAL_TOKENS" ] && [ -n "$SESSION_TIME" ]; then
            FINAL_OUTCOME="${{ steps.claude-autonomous.outcome }}"
            FINAL_ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            FINAL_SESSION_NUMBER="${{ steps.token-check.outputs.session_number }}"
            
            # Provide fallback values
            FINAL_OUTCOME="${FINAL_OUTCOME:-unknown}"
            FINAL_ISSUE_COUNT="${FINAL_ISSUE_COUNT:-0}"
            FINAL_SESSION_NUMBER="${FINAL_SESSION_NUMBER:-1}"
            
            # Skip comprehensive tracking if basic values are missing
            if [ -z "$TOTAL_TOKENS" ]; then
              TOTAL_TOKENS=0
              INPUT_TOKENS=0
              OUTPUT_TOKENS=0
              CACHED_TOKENS=0
              TOKEN_SAVINGS=0
              CACHE_HIT_RATIO=0
            fi
            
            # Update comprehensive usage tracking with error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$FINAL_OUTCOME" \
                   --arg issues "$FINAL_ISSUE_COUNT" \
                   --arg session "$FINAL_SESSION_NUMBER" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "session_number": ($session | tonumber),
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber)
                   }] |
                   .daily_usage += [{
                     "hour": ($time | split(" ")[1] | split(":")[0] | tonumber),
                     "total_tokens": ($total | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "token_savings": ($savings | tonumber)
                   }] |
                   .cache_efficiency += [{
                     "timestamp": $utc,
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "tokens_saved": ($savings | tonumber),
                     "efficiency_score": (if ($total | tonumber) > 0 then (($savings | tonumber) / ($total | tonumber)) else 0 end)
                   }] |
                   .token_savings += [{
                     "timestamp": $utc,
                     "session": ($session | tonumber),
                     "base_cost": ($total | tonumber),
                     "actual_cost": (($total | tonumber) - ($savings | tonumber)),
                     "savings": ($savings | tonumber),
                     "savings_percentage": (if ($total | tonumber) > 0 then ((($savings | tonumber) / ($total | tonumber)) * 100) else 0 end)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "‚ùå Comprehensive tracking failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "‚úÖ Comprehensive usage tracking updated"
            fi
          else
            echo "‚ö†Ô∏è Skipping comprehensive tracking due to missing variables"
          fi
          
          echo "üìä Token Usage Analytics:"
          echo "- Total Tokens: $TOTAL_TOKENS"
          echo "- Input Tokens: $INPUT_TOKENS"
          echo "- Output Tokens: $OUTPUT_TOKENS" 
          echo "- Cached Tokens: $CACHED_TOKENS"
          echo "- Cache Hit Ratio: $(echo "$CACHE_HIT_RATIO * 100" | bc -l | cut -d. -f1)%"
          echo "- Token Savings: $TOKEN_SAVINGS"
          if [ "$TOTAL_TOKENS" -gt 0 ]; then
            echo "- Cost Efficiency: $(echo "scale=1; $TOKEN_SAVINGS * 100 / $TOTAL_TOKENS" | bc -l)%"
          else
            echo "- Cost Efficiency: 0%"
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìä Autonomous Session Summary
        if: always()
        run: |
          echo "ü§ñ **Autonomous Task Completion Summary** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo ""
          echo "**Session Metrics:**"
          echo "- Session: #${{ steps.token-check.outputs.session_number || 'N/A' }}/4"
          echo "- Issues Available: ${{ steps.fetch-issues.outputs.issue_count || 'N/A' }}"
          echo "- Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}"
          echo "- Max Issues: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues || '3' }}"
          echo "- Trigger: ${{ github.event_name == 'schedule' && 'Scheduled (6-hour cycle)' || 'Manual dispatch' }}"
          echo "- Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} remaining"
          echo "- Estimated Usage: ${{ steps.token-check.outputs.estimated_usage || 'Unknown' }} tokens"
          
          # Display cache efficiency summary if usage file exists
          if [ -f ".github/data/token-usage.json" ]; then
            echo ""
            echo "üìà **Token Analytics Summary:**"
            TOTAL_SAVED=$(jq '.token_savings | map(.savings) | add // 0' .github/data/token-usage.json)
            TOTAL_SPENT=$(jq '.session_usage | map(.total_tokens) | add // 0' .github/data/token-usage.json)
            AVG_CACHE_RATIO=$(jq '.cache_efficiency | if length > 0 then map(.cache_hit_ratio) | add / length else 0 end' .github/data/token-usage.json)
            echo "- Total Tokens Saved: $TOTAL_SAVED"
            echo "- Total Tokens Spent: $TOTAL_SPENT"
            echo "- Average Cache Hit Ratio: $(echo "scale=1; $AVG_CACHE_RATIO * 100" | bc -l)%"
            TOTAL_OPERATIONS=$((TOTAL_SPENT + TOTAL_SAVED))
            if [ "$TOTAL_OPERATIONS" -gt 0 ]; then
              echo "- Overall Efficiency: $(echo "scale=1; $TOTAL_SAVED * 100 / $TOTAL_OPERATIONS" | bc -l)%"
            else
              echo "- Overall Efficiency: 0%"
            fi
          fi
          echo ""
          
          if [ "${{ steps.token-check.outputs.proceed }}" = "false" ]; then
            echo "‚ö†Ô∏è Session skipped due to insufficient token budget"
            echo "üí° Token conservation active - will resume next 6-hour cycle or tomorrow"
          elif [ "${{ steps.fetch-issues.outputs.issue_count || '0' }}" -gt 0 ]; then
            echo "‚úÖ Claude autonomous session executed successfully"
            echo "üîç Check the Claude Code action logs for detailed implementation results"
          else
            echo "‚ÑπÔ∏è No eligible issues found for autonomous completion"
            echo "üí° Issues may be labeled as draft, wip, blocked, or no high-priority items available"
          fi
          
          echo ""
          echo "**Next autonomous session:** $(TZ='Australia/Sydney' date -d '+6 hours' +'%Y-%m-%d %H:%M AEST')"

      - name: üîî Notify on Completion
        if: always() && (steps.fetch-issues.outputs.issue_count > 0 || steps.token-check.outputs.proceed == 'false')
        run: |
          # Create a workflow summary with proper command expansion
          SESSION_TIME=$(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          NEXT_SESSION=$(TZ='Australia/Sydney' date -d '+6 hours' +'%Y-%m-%d %H:%M AEST')
          
          # Generate analytics if file exists
          if [ -f ".github/data/usage-tracking.json" ]; then
            ANALYTICS=$(cat .github/data/usage-tracking.json | jq -r '
              "**Total Sessions Today:** " + (.session_usage | length | tostring) + "/4" + "\n" +
              "**Tokens Spent Today:** " + (.session_usage | map(.total_tokens // 0) | add | tostring) + "\n" +
              "**Tokens Saved (Cache):** " + (.session_usage | map(.token_savings // 0) | add | tostring) + "\n" +
              "**Average Cache Hit Ratio:** " + ((.session_usage | map(.cache_hit_ratio // 0) | add / length // 0) * 100 | floor | tostring) + "%" + "\n" +
              "**Cost Efficiency:** " + ((.session_usage | map(if .total_tokens > 0 then (.token_savings // 0) / .total_tokens * 100 else 0 end) | add / length // 0) | floor | tostring) + "% savings"
            ' 2>/dev/null || echo "**Analytics:** Processing first session...")
          else
            ANALYTICS="**Analytics:** Not available yet"
          fi
          
          # Generate issues list
          if [ -f "issues.json" ]; then
            ISSUES_LIST=$(jq -r '.[] | "- **#\(.number):** \(.title)"' issues.json)
          else
            ISSUES_LIST="No issues found for processing"
          fi
          
          # Generate recent sessions
          if [ -f ".github/data/usage-tracking.json" ]; then
            RECENT_SESSIONS=$(cat .github/data/usage-tracking.json | jq -r '
              if (.session_usage | length) > 0 then
                "**Recent Sessions:**\n" +
                (.session_usage | reverse | .[0:3] | map(
                  "- " + (.timestamp // "Unknown") + ": " + ((.total_tokens // 0) | tostring) + " tokens (" + ((.cache_hit_ratio // 0) * 100 | floor | tostring) + "% cached, " + ((.token_savings // 0) | tostring) + " saved)"
                ) | join("\n"))
              else
                "No session data available yet."
              end
            ' 2>/dev/null || echo "Analytics data will be available after first session.")
          else
            RECENT_SESSIONS="Analytics data will be available after first session."
          fi
          
          # Pre-define GitHub variables to avoid substitution issues
          REPO="${{ github.repository }}"
          RUN_ID="${{ github.run_id }}"
          SESSION_NUM="${{ steps.token-check.outputs.session_number }}"
          ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count || '0' }}"
          PRIORITY="${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}"
          TOKEN_BUDGET="${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }}"
          EST_USAGE="${{ steps.token-check.outputs.estimated_usage || 'Unknown' }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ü§ñ Autonomous Task Completion Results
          
          **Session:** $SESSION_TIME (#$SESSION_NUM/4)  
          **Issues Processed:** $ISSUE_COUNT  
          **Priority Level:** $PRIORITY  
          **Token Budget:** $TOKEN_BUDGET remaining  
          **Estimated Usage:** $EST_USAGE tokens
          
          ### üìà Token Analytics:
          $ANALYTICS
          
          ### üìã Issues Targeted:
          $ISSUES_LIST
          
          ### ‚úÖ Results:
          Check the [Claude Code Action logs](https://github.com/$REPO/actions/runs/$RUN_ID) for detailed implementation results and issue closure summaries.
          
          ### ‚è∞ Next Session:
          The next autonomous session will run in 6 hours at: **$NEXT_SESSION**
          
          ### üìä Token Usage Trends:
          $RECENT_SESSIONS
          EOF

      # üîç **STEP 6: WORKFLOW INSPECTION TASK CREATION**
      # Creates a comprehensive GitHub issue for thorough workflow analysis and enhancement
      # suggestions. This task is created periodically to ensure continuous improvement.
      - name: üìã Create Workflow Inspection Task
        if: always() && github.event_name == 'schedule' && steps.token-check.outputs.session_number == '1'
        run: |
          echo "üîç **CREATING WORKFLOW INSPECTION TASK**"
          echo "üìÖ Scheduled workflow inspection for comprehensive analysis"
          echo ""
          
          # Generate comprehensive workflow analysis prompt
          INSPECTION_TITLE="üîç Comprehensive Workflow Analysis: Claude Autonomous Processing System"
          INSPECTION_BODY="## üéØ **Workflow Inspection & Enhancement Request**

          **Created:** $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')  
          **Trigger:** Automated periodic inspection  
          **Scope:** Complete autonomous workflow analysis

          ### üìã **Inspection Objectives**

          Please conduct a thorough analysis of the Claude Autonomous workflow (\`.github/workflows/claude-autonomous.yml\`) and provide detailed enhancement suggestions.

          ### üîç **Analysis Areas**

          #### 1. **Schedule Optimization**
          - **Current:** 6-hour intervals (00:00, 06:00, 12:00, 18:00 AEST)
          - **Analysis Required:** Evaluate optimal timing for maximum effectiveness
          - **Consider:** Token regeneration cycles, GitHub API limits, usage patterns

          #### 2. **Token Management Efficiency**
          - **Current:** Intelligent tier detection with fallback limits
          - **Analysis Required:** Review caching strategies and usage prediction
          - **Consider:** Claude Max/Pro vs API key optimization opportunities

          #### 3. **Priority & Filtering Logic**
          - **Current:** Dynamic fallback (critical‚Üíhigh‚Üímedium‚Üílow)
          - **Analysis Required:** Effectiveness of current priority system
          - **Consider:** Issue complexity scoring, time-based prioritization

          #### 4. **Error Handling & Recovery**
          - **Current:** Comprehensive failure analysis with detailed logging
          - **Analysis Required:** Recovery mechanisms and retry strategies
          - **Consider:** Circuit breaker patterns, graceful degradation

          #### 5. **Analytics & Monitoring**
          - **Current:** Session tracking, token usage, cache efficiency
          - **Analysis Required:** Additional metrics for workflow optimization
          - **Consider:** Performance baselines, success rate tracking

          ### üöÄ **Enhancement Suggestions Requested**

          #### **Performance Optimizations**
          - Workflow execution speed improvements
          - Resource utilization optimization
          - Parallel processing opportunities

          #### **Reliability Improvements**
          - Enhanced error recovery mechanisms
          - Better handling of edge cases
          - Improved authentication management

          #### **Feature Enhancements**
          - Additional automation capabilities
          - Enhanced reporting and analytics
          - Integration with other workflows

          #### **Code Quality**
          - Documentation improvements
          - Code organization and modularity
          - Testing and validation enhancements

          ### üìä **Current Workflow Metrics**
          - **Schedule:** Every 6 hours (4 sessions/day)
          - **Processing Capacity:** 1-3 issues per session
          - **Token Optimization:** Intelligent caching with efficiency tracking
          - **Priority Handling:** Multi-tier fallback system
          - **Error Recovery:** Comprehensive failure analysis

          ### ‚úÖ **Acceptance Criteria**

          - [ ] **Schedule Analysis:** Evaluate current 6-hour intervals vs alternatives
          - [ ] **Token Efficiency:** Review and suggest caching improvements
          - [ ] **Priority System:** Analyze effectiveness of current filtering logic
          - [ ] **Error Handling:** Suggest enhanced recovery mechanisms
          - [ ] **Performance:** Identify workflow execution optimizations
          - [ ] **Monitoring:** Recommend additional analytics and metrics
          - [ ] **Documentation:** Update inline documentation where needed
          - [ ] **Future-Proofing:** Consider scalability and maintainability

          ### üîß **Implementation Guidelines**

          - Focus on **incremental improvements** that maintain current functionality
          - Ensure **backwards compatibility** with existing configuration
          - Prioritize **reliability and stability** over experimental features
          - Provide **detailed rationale** for each suggested enhancement
          - Consider **resource constraints** and GitHub Actions limits

          ### üìà **Success Metrics**

          - Improved workflow reliability and error recovery
          - Enhanced token efficiency and cost optimization
          - Better issue processing throughput and accuracy
          - Clearer documentation and maintainability
          - Future-ready architecture for emerging Claude features

          ---

          ü§ñ **Automated Task Creation** - Generated by Claude Autonomous Workflow  
          üìã **Priority:** High - Workflow optimization directly impacts autonomous effectiveness  
          üîÑ **Frequency:** Created periodically for continuous improvement"

          # Create the GitHub issue
          gh issue create \
            --title "$INSPECTION_TITLE" \
            --body "$INSPECTION_BODY" \
            --label "enhancement,workflow,automation,high-priority" \
            --assignee "@me"
            
          echo "‚úÖ Workflow inspection task created successfully"
          echo "üéØ Issue assigned for comprehensive workflow analysis"
          echo "üìã Labels: enhancement, workflow, automation, high-priority"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}