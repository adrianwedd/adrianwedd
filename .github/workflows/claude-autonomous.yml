name: 🤖 Autonomous Task Completion

on:
  schedule:
    # Run every 4 hours starting at midnight AEST (14:00 UTC)
    - cron: '0 14,18,22,2,6,10 * * *'
  workflow_dispatch:
    inputs:
      max_issues:
        description: 'Maximum number of issues to process'
        required: false
        default: '1'
        type: string
      generate_report:
        description: 'Generate detailed token usage report'
        required: false
        default: true
        type: boolean
      priority_filter:
        description: 'Priority filter (critical, high, medium, low, all)'
        required: false
        default: 'critical'
        type: choice
        options:
          - critical
          - high
          - medium 
          - low
          - all

jobs:
  autonomous-tasks:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read

    steps:
      - name: 📊 Check Usage History (Max/Pro Compatible)
        id: token-check
        run: |
          # Create usage tracking file with Max/Pro account compatibility
          mkdir -p .github/data
          USAGE_FILE=".github/data/usage-tracking.json"
          
          # Detect authentication method for proper limit calculation
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            AUTH_METHOD="anthropic-api"
            echo "🔐 Detected Anthropic API key authentication"
          else
            AUTH_METHOD="none"
            echo "🔧 No authentication - using rule-based processing"
          fi
          
          if [ ! -f "$USAGE_FILE" ]; then
            echo '{
              "auth_method": "'$AUTH_METHOD'",
              "session_usage": [],
              "five_hour_sessions": [],
              "last_session_reset": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "metadata": {
                "max_pro_limits": {
                  "pro_prompts_per_5h": 40,
                  "max_5x_prompts_per_5h": 200,
                  "max_20x_prompts_per_5h": 800,
                  "session_length_hours": 5
                },
                "api_limits": {
                  "daily_tokens": 100000
                },
                "created": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
                "version": "2.0"
              }
            }' > "$USAGE_FILE"
          fi
          
          # Calculate 5-hour session boundaries for Max/Pro accounts
          CURRENT_TIME=$(date -u +%s)
          LAST_SESSION_TIME=$(date -d "$(jq -r '.last_session_reset' "$USAGE_FILE")" +%s 2>/dev/null || echo "0")
          FIVE_HOURS_AGO=$((CURRENT_TIME - 18000)) # 5 hours = 18000 seconds
          
          # Check if we need to reset 5-hour session for Max/Pro
          if [ "$AUTH_METHOD" = "claude-max-oauth" ] && [ "$LAST_SESSION_TIME" -lt "$FIVE_HOURS_AGO" ]; then
            echo "🔄 Resetting 5-hour session limits for Claude Max/Pro account"
            jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '.
              | .five_hour_sessions = []
              | .last_session_reset = $timestamp' "$USAGE_FILE" > "$USAGE_FILE.tmp"
            mv "$USAGE_FILE.tmp" "$USAGE_FILE"
          fi
          
          # Calculate usage limits based on authentication method
          if [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API key - token-based daily limits (detect tier based on usage patterns)
            TOKENS_USED_TODAY=$(jq '.session_usage | map(.total_tokens // 0) | add // 0' "$USAGE_FILE")
            
            # Detect API tier based on typical usage patterns and set appropriate limits
            # Free tier: ~25k tokens/day, Paid tier: ~100k+ tokens/day
            if [ "$TOKENS_USED_TODAY" -gt 50000 ] || [ -n "${{ github.event.inputs.force_paid_tier }}" ]; then
              DAILY_TOKENS=200000  # Paid tier - more generous limit
              API_TIER="paid"
              MIN_TOKENS=10000     # Higher threshold for paid accounts
            else
              DAILY_TOKENS=25000   # Free tier - conservative limit
              API_TIER="free"
              MIN_TOKENS=2000      # Lower threshold for free accounts
            fi
            
            TOKENS_REMAINING=$((DAILY_TOKENS - TOKENS_USED_TODAY))
            
            echo "📊 Anthropic API Usage Analysis:"
            echo "- Account Type: API Key ($API_TIER tier)"
            echo "- Daily Limit: $DAILY_TOKENS tokens"
            echo "- Used Today: $TOKENS_USED_TODAY tokens"
            echo "- Remaining: $TOKENS_REMAINING tokens"
            echo "- Minimum Required: $MIN_TOKENS tokens"
            
            if [ "$TOKENS_REMAINING" -lt "$MIN_TOKENS" ]; then
              echo "⚠️ Insufficient token budget remaining for $API_TIER tier"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "limit_reason=token_limit" >> $GITHUB_OUTPUT
            elif [ "$API_TIER" = "free" ] && [ "$TOKENS_REMAINING" -lt 10000 ]; then
              echo "💡 Limited tokens remaining on free tier, reducing scope"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=1" >> $GITHUB_OUTPUT
            else
              echo "✅ Sufficient tokens available for $API_TIER tier"
              echo "proceed=true" >> $GITHUB_OUTPUT
              echo "max_issues=$( [ "$API_TIER" = "free" ] && echo "2" || echo "3" )" >> $GITHUB_OUTPUT
            fi
            
            # Set estimated usage based on tier and remaining tokens
            ESTIMATED_USAGE=$( [ "$API_TIER" = "free" ] && echo "3000" || echo "8000" )
            echo "estimated_usage=$ESTIMATED_USAGE" >> $GITHUB_OUTPUT
            echo "tokens_remaining=$TOKENS_REMAINING" >> $GITHUB_OUTPUT
            echo "api_tier=$API_TIER" >> $GITHUB_OUTPUT
            
          else
            # No authentication - always proceed with rule-based processing
            echo "📊 Rule-based Processing (No API limits):"
            echo "- Mode: Issue analysis and suggestions only"
            echo "- No external API calls required"
            echo "✅ Always available for rule-based automation"
            
            echo "proceed=true" >> $GITHUB_OUTPUT
            echo "max_issues=5" >> $GITHUB_OUTPUT
            echo "estimated_usage=none" >> $GITHUB_OUTPUT
            echo "limit_reason=none" >> $GITHUB_OUTPUT
            echo "tokens_remaining=unlimited" >> $GITHUB_OUTPUT  # For compatibility
          fi
          
          echo "auth_method=$AUTH_METHOD" >> $GITHUB_OUTPUT
          echo "session_number=1" >> $GITHUB_OUTPUT
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🚀 Checkout Repository  
        if: steps.token-check.outputs.proceed == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔍 Fetch Open Issues
        id: fetch-issues
        if: steps.token-check.outputs.proceed == 'true'
        run: |
          # Fetch open issues with specific labels and priorities
          PRIORITY_FILTER="${{ github.event.inputs.priority_filter || 'high' }}"
          MAX_ISSUES="${{ github.event.inputs.max_issues || steps.token-check.outputs.max_issues || '3' }}"
          
          # Build label filter with fallback priority strategy
          echo "🔍 Searching for issues with priority: $PRIORITY_FILTER"
          
          if [ "$PRIORITY_FILTER" = "all" ]; then
            echo "📋 Using no priority filter - checking all open issues"
          else
            echo "🎯 Filtering for \"priority: ${PRIORITY_FILTER}\" issues"
          fi
          
          # Fetch issues (excluding draft, wip, blocked)
          echo "📥 Fetching open issues..."
          if [ "$PRIORITY_FILTER" = "all" ]; then
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --json number,title,labels,body,url > all_issues.json
          else
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: ${PRIORITY_FILTER}" \
              --json number,title,labels,body,url > all_issues.json
          fi
          
          # Filter out draft, wip, blocked issues
          jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues.json > issues.json
          
          # Debug: Show what we fetched
          echo "🔍 Debug: Issues fetched from GitHub:"
          cat all_issues.json | jq length
          echo "🔍 Debug: Issues after filtering:"
          cat issues.json | jq length
          
          # Get count with error handling
          ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
          echo "📊 Found $ISSUE_COUNT issues with priority:${PRIORITY_FILTER}"
          
          # Ensure ISSUE_COUNT is a valid integer
          if [ -z "$ISSUE_COUNT" ] || ! [[ "$ISSUE_COUNT" =~ ^[0-9]+$ ]]; then
            ISSUE_COUNT="0"
          fi
          
          # If no high priority issues found, try medium priority
          if [ "$ISSUE_COUNT" -eq 0 ] && [ "$PRIORITY_FILTER" = "high" ]; then
            echo "⬇️ No high priority issues found, falling back to medium priority..."
            gh issue list \
              --state open \
              --limit "$MAX_ISSUES" \
              --label "priority: medium" \
              --json number,title,labels,body,url > all_issues_medium.json
            
            # Filter out draft, wip, blocked issues
            jq '[.[] | select(.labels | map(.name) | any(. | test("^(draft|wip|blocked)$"; "i")) | not)]' all_issues_medium.json > issues.json
            
            ISSUE_COUNT=$(jq length issues.json 2>/dev/null || echo "0")
            echo "📊 Found $ISSUE_COUNT medium priority issues"
            PRIORITY_FILTER="medium (fallback)"
          fi
          
          echo "✅ Final issue count: $ISSUE_COUNT eligible issues for processing"
          echo "issue_count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
          echo "actual_priority=$PRIORITY_FILTER" >> $GITHUB_OUTPUT
          
          if [ "$ISSUE_COUNT" -gt 0 ]; then
            # Create structured prompt for Claude
            PROMPT="🤖 **Autonomous Task Completion Session** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## 📋 **Task Instructions**
          Please analyze and complete the following GitHub issues autonomously:
          
          $(jq -r '.[] | "### Issue #\(.number): \(.title)\n**URL:** \(.url)\n**Labels:** \(.labels | map(.name) | join(", "))\n**Description:**\n\(.body)\n---\n"' issues.json)
          
          ## 🎯 **Completion Criteria**
          For each issue:
          1. **Analyze** the requirements and technical scope
          2. **Implement** the solution following our coding standards  
          3. **Test** the implementation thoroughly
          4. **Document** any significant changes
          5. **Close** the issue with a comprehensive summary
          
          ## ⚙️ **Technical Guidelines**
          - Follow existing code patterns and architecture
          - Add sophisticated emoji to enhance readability
          - Ensure accessibility and performance standards
          - Run tests and fix any failures
          - Use TodoWrite tool to track progress
          - Commit changes with descriptive messages
          
          ## 🚀 **Execution Priority**
          - Focus on **highest priority** issues first
          - Group **related issues** for efficient implementation
          - **Skip** any issue that seems too complex for autonomous completion
          - **Document** any issues requiring human intervention
          
          ## 📊 **Success Metrics**
          - Issues successfully implemented and closed
          - Tests passing and code quality maintained
          - Clear documentation and commit messages
          - Proper issue closure with comprehensive summaries
          
          Begin autonomous task completion now. Use your best judgment for technical decisions and implementation approaches."
          
            echo "prompt<<EOF" >> $GITHUB_OUTPUT
            echo "$PROMPT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "prompt=No eligible issues found for autonomous completion." >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: 🚀 Begin Autonomous Session
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "🤖 **AUTONOMOUS SESSION STARTING**"
          echo "📅 Session #${{ steps.token-check.outputs.session_number }}/6 at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "🎯 Processing ${{ steps.fetch-issues.outputs.issue_count }} issues with priority: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "💰 Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo "📊 Estimated usage: ${{ steps.token-check.outputs.estimated_usage }} tokens"
          echo ""
          echo "📋 **Issues to be processed:**"
          jq -r '.[] | "  #\(.number): \(.title) (\(.labels | map(.name) | join(", ")))"' issues.json
          echo ""
          echo "🚀 **Launching Claude Code autonomous execution...**"

      - name: 📦 Setup Node.js for Custom Executor
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: 🚀 Install Custom Executor Dependencies
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        run: |
          echo "📦 **INSTALLING CUSTOM EXECUTOR DEPENDENCIES**"
          cd .github/scripts
          npm install
          cd ../..
          echo "✅ Dependencies installed"

      - name: 🤖 Run Autonomous Processing
        if: steps.fetch-issues.outputs.issue_count > 0 && steps.token-check.outputs.proceed == 'true'
        id: claude-autonomous
        run: |
          echo "🤖 **LAUNCHING AUTONOMOUS PROCESSING**"
          echo "📋 Processing ${{ steps.fetch-issues.outputs.issue_count }} issues"
          echo "🎯 Session #${{ steps.token-check.outputs.session_number }}/6"
          echo "💰 Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining"
          echo ""
          
          # Check API key first (currently supported), then OAuth (future support)
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "🧠 **USING CLAUDE AI AUTONOMOUS EXECUTOR (API Key)**"
            echo "✅ Anthropic API key detected - full AI-powered automation enabled"
            echo ""
            
            # Create enhanced prompt file to avoid shell parsing issues
            cat > enhanced_prompt.txt << 'PROMPT_EOF'
          🤖 **AUTONOMOUS EXECUTION SESSION** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          
          ## 📊 **Session Context**
          - Session #${{ steps.token-check.outputs.session_number }}/6
          - Token budget: ${{ steps.token-check.outputs.tokens_remaining }} remaining
          - Target usage: ${{ steps.token-check.outputs.estimated_usage }} tokens
          - Issues to process: ${{ steps.fetch-issues.outputs.issue_count }}
          
          ## 🎯 **Enhanced Instructions**
          ${{ steps.fetch-issues.outputs.prompt }}
          
          ## ⚡ **Efficiency Guidelines**
          - Use prompt caching extensively for repeated contexts
          - Implement efficient, focused solutions  
          - Prioritize high-impact, low-complexity tasks when token budget is limited
          - Track and report: input_tokens, output_tokens for analysis
          
          ## 🔧 **Technical Excellence**
          - Follow existing code patterns and architecture
          - Use sophisticated emoji for enhanced readability
          - Comprehensive issue closure summaries with proper emoji
          - Test implementations before closing issues
          - Proper issue closure with comprehensive summaries
          
          Begin autonomous task completion now. Use your best judgment for technical decisions and implementation approaches.
          PROMPT_EOF
            
            # Execute OAuth-compatible autonomous script (API key fallback)
            AUTONOMOUS_PROMPT="$(cat enhanced_prompt.txt)" ISSUES_JSON="$(cat issues.json)" node .github/scripts/claude-oauth-executor.js
          else
            echo "🔧 **USING RULE-BASED ISSUE PROCESSOR**"
            echo "💡 No API key - using intelligent automation without external APIs"
            echo ""
            
            # Execute rule-based issue processor
            ISSUES_JSON="$(cat issues.json)" node .github/scripts/issue-processor.js
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUTONOMOUS_PROMPT: ${{ steps.fetch-issues.outputs.prompt }}
          ISSUES_JSON: ${{ steps.fetch-issues.outputs.issues }}

      - name: ⚠️ Autonomous Processing Failed - Detailed Analysis
        if: steps.claude-autonomous.outcome == 'failure'
        run: |
          echo "⚠️ **AUTONOMOUS PROCESSING FAILED - DETAILED ERROR ANALYSIS**"
          echo "================================================="
          echo ""
          
          # Capture and display exit code details
          AUTONOMOUS_EXIT_CODE="${{ steps.claude-autonomous.outputs.exit_code || 'unknown' }}"
          echo "🔍 **Exit Code**: $AUTONOMOUS_EXIT_CODE"
          echo ""
          
          # Authentication method diagnosis
          echo "🔐 **Authentication Analysis**:"
          if [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  ✅ Anthropic API Key: Present"
            echo "  📋 Account Type: ${{ steps.token-check.outputs.auth_method }}"
            echo "  🎯 Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} tokens remaining"
          else
            echo "  ❌ No authentication detected"
            echo "  📋 Fallback Mode: Rule-based issue processor only"
          fi
          echo ""
          
          # Issue processing context
          echo "🎯 **Issue Processing Context**:"
          echo "  📊 Issues Found: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "  🏷️ Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo "  📋 Max Issues Setting: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues }}"
          echo ""
          
          # List specific issues that failed
          echo "📋 **Issues That Failed Processing**:"
          if [ -f "issues.json" ]; then
            jq -r '.[] | "  🔸 Issue #\(.number): \(.title)\n    🔗 URL: \(.url)\n    🏷️ Labels: \(.labels | map(.name) | join(", "))\n"' issues.json
          else
            echo "  ❌ issues.json not found - issue fetching may have failed"
          fi
          echo ""
          
          # Check for specific error patterns
          echo "🔍 **Error Pattern Analysis**:"
          
          # Check if it's a dependency issue
          if ! command -v node &> /dev/null; then
            echo "  ❌ Node.js not available - dependency missing"
          else
            echo "  ✅ Node.js available: $(node --version)"
          fi
          
          # Check script accessibility
          if [ ! -f ".github/scripts/claude-oauth-executor.js" ]; then
            echo "  ❌ OAuth executor script missing"
          else
            echo "  ✅ OAuth executor script present"
          fi
          
          if [ ! -f ".github/scripts/issue-processor.js" ]; then
            echo "  ❌ Issue processor script missing"
          else
            echo "  ✅ Issue processor script present"
          fi
          
          # Check npm dependencies
          if [ ! -f ".github/scripts/package.json" ]; then
            echo "  ⚠️ package.json missing in scripts directory"
          else
            echo "  ✅ package.json present"
            if [ ! -d ".github/scripts/node_modules" ]; then
              echo "  ❌ node_modules not installed"
            else
              echo "  ✅ node_modules installed"
            fi
          fi
          echo ""
          
          # Network and API diagnostics
          echo "🌐 **Network & API Diagnostics**:"
          if [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "  🔍 Testing Anthropic API connectivity..."
            if curl -s --max-time 10 https://api.anthropic.com > /dev/null; then
              echo "  ✅ Anthropic API endpoint reachable"
            else
              echo "  ❌ Anthropic API endpoint unreachable"
            fi
          else
            echo "  ℹ️ No API authentication - network check skipped"
          fi
          echo ""
          
          # Suggested remediation steps
          echo "🔧 **Suggested Remediation Steps**:"
          echo "  1. 📋 Check GitHub Actions logs above for specific error messages"
          echo "  2. 🔍 Verify authentication tokens are properly configured in repository secrets"
          echo "  3. 🧪 Test autonomous scripts locally with: cd .github/scripts && npm test"
          echo "  4. 📊 Check usage limits for your account type (Max/Pro vs API)"
          echo "  5. 🔄 Try manual workflow dispatch with different parameters"
          echo "  6. 📞 If issues persist, check Anthropic service status"
          echo ""
          
          # Save failure context for analysis
          echo "💾 **Saving Failure Context**:"
          mkdir -p .github/data/failure-logs
          FAILURE_LOG=".github/data/failure-logs/failure-$(date +%Y%m%d-%H%M%S).json"
          cat > "$FAILURE_LOG" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "trigger": "${{ github.event_name }}",
            "auth_method": "${{ steps.token-check.outputs.auth_method }}",
            "exit_code": "$AUTONOMOUS_EXIT_CODE",
            "issues_count": "${{ steps.fetch-issues.outputs.issue_count }}",
            "priority_filter": "${{ steps.fetch-issues.outputs.actual_priority }}",
            "workflow_run_id": "${{ github.run_id }}",
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.sha }}"
          }
          EOF
          echo "  📄 Failure context saved to: $FAILURE_LOG"
          echo ""
          
          echo "================================================="
          echo "🔍 **For detailed logs, check the workflow run at:**"
          echo "🔗 https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: 📊 Autonomous Session Complete
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          echo "🏁 **AUTONOMOUS SESSION COMPLETED**"
          echo "📅 Finished at $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo "✅ Session outcome: ${{ steps.claude-autonomous.outcome }}"
          echo "🎯 Issues processed: ${{ steps.fetch-issues.outputs.issue_count }}"
          echo "📊 Priority level: ${{ steps.fetch-issues.outputs.actual_priority }}"
          echo ""

      - name: 💾 Record Usage Analytics (Max/Pro Compatible)
        if: always() && steps.claude-autonomous.outcome != 'skipped'
        run: |
          # Record session usage based on account type
          USAGE_FILE=".github/data/usage-tracking.json"
          SESSION_TIME=$(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          SESSION_UTC=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          AUTH_METHOD="${{ steps.token-check.outputs.auth_method }}"
          
          echo "🔍 Debug: AUTH_METHOD is: $AUTH_METHOD"
          echo "🔍 Debug: API key present: ${{ secrets.ANTHROPIC_API_KEY != '' }}"
          
          # Ensure usage file exists with proper structure
          mkdir -p .github/data
          if [ ! -f "$USAGE_FILE" ]; then
            echo "📁 Creating new usage tracking file"
            jq -n \
              --arg auth_method "$AUTH_METHOD" \
              --arg last_reset "$SESSION_UTC" \
              --arg created "$SESSION_UTC" \
              '{
                "auth_method": $auth_method,
                "session_usage": [],
                "five_hour_sessions": [],
                "last_session_reset": $last_reset,
                "metadata": {
                  "max_pro_limits": {
                    "pro_prompts_per_5h": 40,
                    "max_5x_prompts_per_5h": 200,
                    "max_20x_prompts_per_5h": 800,
                    "session_length_hours": 5
                  },
                  "api_limits": {
                    "daily_tokens": 100000,
                    "free_tier_tokens": 25000,
                    "paid_tier_tokens": 200000
                  },
                  "created": $created,
                  "version": "2.1"
                }
              }' > "$USAGE_FILE"
          fi
          
          # Record usage based on authentication method
          if [ "$AUTH_METHOD" = "claude-max-oauth" ]; then
            # Max/Pro account - record prompt usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              PROMPTS_USED=3  # Conservative estimate for successful run
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              PROMPTS_USED=1  # Partial execution
            else
              PROMPTS_USED=0  # Skipped
            fi
            
            echo "📊 Max/Pro Usage Recording:"
            echo "- Prompts Used: $PROMPTS_USED"
            echo "- Session Outcome: ${{ steps.claude-autonomous.outcome }}"
            echo "- Issues Processed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with prompt-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values for empty variables
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            PROMPTS_USED="${PROMPTS_USED:-0}"
            
            echo "🔍 Debug: Variables before jq:"
            echo "  SESSION_TIME: $SESSION_TIME"
            echo "  SESSION_UTC: $SESSION_UTC"
            echo "  PROMPTS_USED: $PROMPTS_USED"
            echo "  OUTCOME: $OUTCOME"
            echo "  ISSUE_COUNT: $ISSUE_COUNT"
            echo "  AUTH_METHOD: $AUTH_METHOD"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg prompts "$PROMPTS_USED" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .five_hour_sessions += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }] |
                   .session_usage += [{
                     "timestamp": $time,
                     "type": "claude_max_pro",
                     "prompts_used": ($prompts | tonumber),
                     "outcome": $outcome,
                     "issues_count": ($issues | tonumber)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "❌ jq command failed, attempting manual JSON creation"
              # Fallback to manual JSON creation if jq fails
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
              echo "⚠️ Usage tracking update failed, keeping original file"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "✅ Usage tracking updated successfully"
            fi
            
          elif [ "$AUTH_METHOD" = "anthropic-api" ]; then
            # API account - estimate token usage
            if [ "${{ steps.claude-autonomous.outcome }}" = "success" ]; then
              TOTAL_TOKENS=5000  # Conservative estimate
              CACHE_HIT_RATIO=0.65
            elif [ "${{ steps.claude-autonomous.outcome }}" = "failure" ]; then
              TOTAL_TOKENS=2500  # Partial execution
              CACHE_HIT_RATIO=0.3
            else
              TOTAL_TOKENS=0
              CACHE_HIT_RATIO=0
            fi
            
            CACHED_TOKENS=$((TOTAL_TOKENS * 65 / 100))
            INPUT_TOKENS=$((TOTAL_TOKENS * 60 / 100))
            OUTPUT_TOKENS=$((TOTAL_TOKENS * 40 / 100))
            TOKEN_SAVINGS=$((CACHED_TOKENS * 75 / 100))
            
            echo "📊 API Token Usage Recording:"
            echo "- Total Tokens: $TOTAL_TOKENS"
            echo "- Cached Tokens: $CACHED_TOKENS"
            echo "- Token Savings: $TOKEN_SAVINGS"
            
            # Update usage file with token-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "❌ jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "✅ Usage tracking updated successfully"
            fi
            
          else
            # No auth - record rule-based processing
            echo "📊 Rule-based Processing Recording:"
            echo "- Mode: API-free issue analysis"
            echo "- Issues Analyzed: ${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Update usage file with rule-based tracking (with validation)
            OUTCOME="${{ steps.claude-autonomous.outcome }}"
            ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            
            # Provide fallback values
            OUTCOME="${OUTCOME:-unknown}"
            ISSUE_COUNT="${ISSUE_COUNT:-0}"
            
            # Update usage file with proper error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg outcome "$OUTCOME" \
                   --arg issues "$ISSUE_COUNT" \
                   --arg auth "$AUTH_METHOD" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "type": "rule_based",
                     "outcome": $outcome,
                     "issues_analyzed": ($issues | tonumber),
                     "auth_method": $auth
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "❌ jq command failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "✅ Usage tracking updated successfully"
            fi
          fi
          
          # Update comprehensive usage tracking with cache analytics (if variables available)
          if [ -n "$TOTAL_TOKENS" ] && [ -n "$SESSION_TIME" ]; then
            FINAL_OUTCOME="${{ steps.claude-autonomous.outcome }}"
            FINAL_ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count }}"
            FINAL_SESSION_NUMBER="${{ steps.token-check.outputs.session_number }}"
            
            # Provide fallback values
            FINAL_OUTCOME="${FINAL_OUTCOME:-unknown}"
            FINAL_ISSUE_COUNT="${FINAL_ISSUE_COUNT:-0}"
            FINAL_SESSION_NUMBER="${FINAL_SESSION_NUMBER:-1}"
            
            # Skip comprehensive tracking if basic values are missing
            if [ -z "$TOTAL_TOKENS" ]; then
              TOTAL_TOKENS=0
              INPUT_TOKENS=0
              OUTPUT_TOKENS=0
              CACHED_TOKENS=0
              TOKEN_SAVINGS=0
              CACHE_HIT_RATIO=0
            fi
            
            # Update comprehensive usage tracking with error handling
            if ! jq --arg time "$SESSION_TIME" \
                   --arg utc "$SESSION_UTC" \
                   --arg total "$TOTAL_TOKENS" \
                   --arg input "$INPUT_TOKENS" \
                   --arg output "$OUTPUT_TOKENS" \
                   --arg cached "$CACHED_TOKENS" \
                   --arg savings "$TOKEN_SAVINGS" \
                   --arg cache_ratio "$CACHE_HIT_RATIO" \
                   --arg outcome "$FINAL_OUTCOME" \
                   --arg issues "$FINAL_ISSUE_COUNT" \
                   --arg session "$FINAL_SESSION_NUMBER" \
                   '. as $root |
                   .session_usage += [{
                     "timestamp": $time,
                     "utc_timestamp": $utc,
                     "session_number": ($session | tonumber),
                     "total_tokens": ($total | tonumber),
                     "input_tokens": ($input | tonumber),
                     "output_tokens": ($output | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "token_savings": ($savings | tonumber),
                     "outcome": $outcome,
                     "issues_processed": ($issues | tonumber)
                   }] |
                   .daily_usage += [{
                     "hour": ($time | split(" ")[1] | split(":")[0] | tonumber),
                     "total_tokens": ($total | tonumber),
                     "cached_tokens": ($cached | tonumber),
                     "token_savings": ($savings | tonumber)
                   }] |
                   .cache_efficiency += [{
                     "timestamp": $utc,
                     "cache_hit_ratio": ($cache_ratio | tonumber),
                     "tokens_saved": ($savings | tonumber),
                     "efficiency_score": (if ($total | tonumber) > 0 then (($savings | tonumber) / ($total | tonumber)) else 0 end)
                   }] |
                   .token_savings += [{
                     "timestamp": $utc,
                     "session": ($session | tonumber),
                     "base_cost": ($total | tonumber),
                     "actual_cost": (($total | tonumber) - ($savings | tonumber)),
                     "savings": ($savings | tonumber),
                     "savings_percentage": (if ($total | tonumber) > 0 then ((($savings | tonumber) / ($total | tonumber)) * 100) else 0 end)
                   }]' "$USAGE_FILE" > "$USAGE_FILE.tmp"; then
              echo "❌ Comprehensive tracking failed, keeping original file"
              cp "$USAGE_FILE" "$USAGE_FILE.backup"
            else
              mv "$USAGE_FILE.tmp" "$USAGE_FILE"
              echo "✅ Comprehensive usage tracking updated"
            fi
          else
            echo "⚠️ Skipping comprehensive tracking due to missing variables"
          fi
          
          echo "📊 Token Usage Analytics:"
          echo "- Total Tokens: $TOTAL_TOKENS"
          echo "- Input Tokens: $INPUT_TOKENS"
          echo "- Output Tokens: $OUTPUT_TOKENS" 
          echo "- Cached Tokens: $CACHED_TOKENS"
          echo "- Cache Hit Ratio: $(echo "$CACHE_HIT_RATIO * 100" | bc -l | cut -d. -f1)%"
          echo "- Token Savings: $TOKEN_SAVINGS"
          if [ "$TOTAL_TOKENS" -gt 0 ]; then
            echo "- Cost Efficiency: $(echo "scale=1; $TOKEN_SAVINGS * 100 / $TOTAL_TOKENS" | bc -l)%"
          else
            echo "- Cost Efficiency: 0%"
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 📊 Autonomous Session Summary
        if: always()
        run: |
          echo "🤖 **Autonomous Task Completion Summary** - $(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')"
          echo ""
          echo "**Session Metrics:**"
          echo "- Session: #${{ steps.token-check.outputs.session_number || 'N/A' }}/6"
          echo "- Issues Available: ${{ steps.fetch-issues.outputs.issue_count || 'N/A' }}"
          echo "- Priority Filter: ${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}"
          echo "- Max Issues: ${{ steps.token-check.outputs.max_issues || github.event.inputs.max_issues || '3' }}"
          echo "- Trigger: ${{ github.event_name == 'schedule' && 'Scheduled (4-hour cycle)' || 'Manual dispatch' }}"
          echo "- Token Budget: ${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }} remaining"
          echo "- Estimated Usage: ${{ steps.token-check.outputs.estimated_usage || 'Unknown' }} tokens"
          
          # Display cache efficiency summary if usage file exists
          if [ -f ".github/data/token-usage.json" ]; then
            echo ""
            echo "📈 **Token Analytics Summary:**"
            TOTAL_SAVED=$(jq '.token_savings | map(.savings) | add // 0' .github/data/token-usage.json)
            TOTAL_SPENT=$(jq '.session_usage | map(.total_tokens) | add // 0' .github/data/token-usage.json)
            AVG_CACHE_RATIO=$(jq '.cache_efficiency | if length > 0 then map(.cache_hit_ratio) | add / length else 0 end' .github/data/token-usage.json)
            echo "- Total Tokens Saved: $TOTAL_SAVED"
            echo "- Total Tokens Spent: $TOTAL_SPENT"
            echo "- Average Cache Hit Ratio: $(echo "scale=1; $AVG_CACHE_RATIO * 100" | bc -l)%"
            TOTAL_OPERATIONS=$((TOTAL_SPENT + TOTAL_SAVED))
            if [ "$TOTAL_OPERATIONS" -gt 0 ]; then
              echo "- Overall Efficiency: $(echo "scale=1; $TOTAL_SAVED * 100 / $TOTAL_OPERATIONS" | bc -l)%"
            else
              echo "- Overall Efficiency: 0%"
            fi
          fi
          echo ""
          
          if [ "${{ steps.token-check.outputs.proceed }}" = "false" ]; then
            echo "⚠️ Session skipped due to insufficient token budget"
            echo "💡 Token conservation active - will resume next cycle or tomorrow"
          elif [ "${{ steps.fetch-issues.outputs.issue_count || '0' }}" -gt 0 ]; then
            echo "✅ Claude autonomous session executed successfully"
            echo "🔍 Check the Claude Code action logs for detailed implementation results"
          else
            echo "ℹ️ No eligible issues found for autonomous completion"
            echo "💡 Issues may be labeled as draft, wip, blocked, or no high-priority items available"
          fi
          
          echo ""
          echo "**Next autonomous session:** $(TZ='Australia/Sydney' date -d '+4 hours' +'%Y-%m-%d %H:%M AEST')"

      - name: 🔔 Notify on Completion
        if: always() && (steps.fetch-issues.outputs.issue_count > 0 || steps.token-check.outputs.proceed == 'false')
        run: |
          # Create a workflow summary with proper command expansion
          SESSION_TIME=$(TZ='Australia/Sydney' date +'%Y-%m-%d %H:%M AEST')
          NEXT_SESSION=$(TZ='Australia/Sydney' date -d '+4 hours' +'%Y-%m-%d %H:%M AEST')
          
          # Generate analytics if file exists
          if [ -f ".github/data/usage-tracking.json" ]; then
            ANALYTICS=$(cat .github/data/usage-tracking.json | jq -r '
              "**Total Sessions Today:** " + (.session_usage | length | tostring) + "/6" + "\n" +
              "**Tokens Spent Today:** " + (.session_usage | map(.total_tokens // 0) | add | tostring) + "\n" +
              "**Tokens Saved (Cache):** " + (.session_usage | map(.token_savings // 0) | add | tostring) + "\n" +
              "**Average Cache Hit Ratio:** " + ((.session_usage | map(.cache_hit_ratio // 0) | add / length // 0) * 100 | floor | tostring) + "%" + "\n" +
              "**Cost Efficiency:** " + ((.session_usage | map(if .total_tokens > 0 then (.token_savings // 0) / .total_tokens * 100 else 0 end) | add / length // 0) | floor | tostring) + "% savings"
            ' 2>/dev/null || echo "**Analytics:** Processing first session...")
          else
            ANALYTICS="**Analytics:** Not available yet"
          fi
          
          # Generate issues list
          if [ -f "issues.json" ]; then
            ISSUES_LIST=$(jq -r '.[] | "- **#\(.number):** \(.title)"' issues.json)
          else
            ISSUES_LIST="No issues found for processing"
          fi
          
          # Generate recent sessions
          if [ -f ".github/data/usage-tracking.json" ]; then
            RECENT_SESSIONS=$(cat .github/data/usage-tracking.json | jq -r '
              if (.session_usage | length) > 0 then
                "**Recent Sessions:**\n" +
                (.session_usage | reverse | .[0:3] | map(
                  "- " + (.timestamp // "Unknown") + ": " + ((.total_tokens // 0) | tostring) + " tokens (" + ((.cache_hit_ratio // 0) * 100 | floor | tostring) + "% cached, " + ((.token_savings // 0) | tostring) + " saved)"
                ) | join("\n"))
              else
                "No session data available yet."
              end
            ' 2>/dev/null || echo "Analytics data will be available after first session.")
          else
            RECENT_SESSIONS="Analytics data will be available after first session."
          fi
          
          # Pre-define GitHub variables to avoid substitution issues
          REPO="${{ github.repository }}"
          RUN_ID="${{ github.run_id }}"
          SESSION_NUM="${{ steps.token-check.outputs.session_number }}"
          ISSUE_COUNT="${{ steps.fetch-issues.outputs.issue_count || '0' }}"
          PRIORITY="${{ steps.fetch-issues.outputs.actual_priority || github.event.inputs.priority_filter || 'high' }}"
          TOKEN_BUDGET="${{ steps.token-check.outputs.tokens_remaining || 'Unknown' }}"
          EST_USAGE="${{ steps.token-check.outputs.estimated_usage || 'Unknown' }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🤖 Autonomous Task Completion Results
          
          **Session:** $SESSION_TIME (#$SESSION_NUM/6)  
          **Issues Processed:** $ISSUE_COUNT  
          **Priority Level:** $PRIORITY  
          **Token Budget:** $TOKEN_BUDGET remaining  
          **Estimated Usage:** $EST_USAGE tokens
          
          ### 📈 Token Analytics:
          $ANALYTICS
          
          ### 📋 Issues Targeted:
          $ISSUES_LIST
          
          ### ✅ Results:
          Check the [Claude Code Action logs](https://github.com/$REPO/actions/runs/$RUN_ID) for detailed implementation results and issue closure summaries.
          
          ### ⏰ Next Session:
          The next autonomous session will run in 4 hours at: **$NEXT_SESSION**
          
          ### 📊 Token Usage Trends:
          $RECENT_SESSIONS
          EOF